<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Gemini Output</title>
<style>
    body {font-family:'Segoe UI',Arial,sans-serif; background:#f7fafc; color:#23262f; max-width:900px; margin:32px auto; padding:40px 40px 64px 40px; box-shadow:0 8px 32px #0001; border-radius:16px;}
    h1,h2,h3 {color:#256ad9; margin-top:2em;}
    h1 {font-size:2.4em;}
    h2 {font-size:1.6em;}
    h3 {font-size:1.2em;}
    blockquote {background:#e7f2ff; border-left:6px solid #256ad9; margin:20px 0; padding:12px 22px;}
    pre, code {background:#e3e7ef; color:#1943b6; font-size:1em; border-radius:6px;}
    pre {padding:16px; overflow-x:auto;}
    code {padding:2px 5px;}
    table {border-collapse:collapse; margin:24px 0; background:#fff;}
    th, td {border:1px solid #dbe3ee; padding:8px 16px;}
    tr:nth-child(even) {background:#f6f9fe;}
    ul,ol {margin-left:32px;}
    hr {border:0; border-top:1px solid #dbe3ee; margin:36px 0;}
    </style>
</head>
<body>
<h1 id="глава-1-введение-в-python-и-основы-программирования">
 Глава 1: Введение в Python и основы программирования
</h1>
<h2 id="11-добро-пожаловать-на-курс">
 1.1. Добро пожаловать на курс
</h2>
<p>
 Приветствуем вас на курсе по языку программирования Python! Эта программа обучения создана с акцентом на практическое применение знаний. Наша цель — не просто изложить сухую теорию о языке, а научить вас программировать, освоив этот навык с нуля.
</p>
<p>
 Помимо самого языка, курс охватывает множество смежных и необходимых тем, включая:
</p>
<ul>
 <li>
  Принципы работы процессов в операционных системах.
 </li>
 <li>
  Практическое использование терминала (командной строки).
 </li>
 <li>
  Взаимодействие с файловой системой на различных платформах (Windows, macOS, Linux).
 </li>
</ul>
<p>
 Курс ориентирован на реальное применение инструментов языка. Вы узнаете, как и когда использовать те или иные возможности Python для решения практических задач, будь то автоматизация бизнеса, запуск личного проекта или развитие хобби, которое может перерасти в собственное дело.
</p>
<p>
 Python продолжает стремительно набирать популярность, укрепляя свои позиции как один из ведущих языков программирования. Изучая его, вы можете быть уверены, что приобретаете актуальный и востребованный навык, который станет вашим ключом к трудоустройству и позволит быть технически подкованным в современном мире технологий.
</p>
<h3 id="о-преподавателе-и-структуре-курса">
 О преподавателе и структуре курса
</h3>
<p>
 Меня зовут Александр, я full-stack веб-разработчик с семилетним практическим опытом. Как и вы, я когда-то начинал с нуля, и теперь, параллельно с основной работой, занимаюсь обучением, делясь накопленными знаниями и понимая потребности начинающих программистов.
</p>
<p>
 Данный курс структурирован для максимального удобства. Под видео вы найдете:
</p>
<ul>
 <li>
  <strong>
   Содержание с временными метками:
  </strong>
  для быстрой навигации по темам.
 </li>
 <li>
  <strong>
   Дополнительные материалы:
  </strong>
  все необходимые файлы для скачивания, о которых будет рассказано в соответствующих разделах.
 </li>
</ul>
<blockquote>
 <p>
  <strong>
   Фуллстек-разработчик (Full-stack developer)
  </strong>
  — это специалист, который обладает компетенциями для работы как с клиентской (front-end), так и с серверной (back-end) частью веб-приложения. Он способен создать и поддерживать проект целиком, от пользовательского интерфейса до базы данных.
 </p>
</blockquote>
<p>
 <strong>
  Важно:
 </strong>
 На платформе YouTube размещена неполная версия курса. Она позволит вам оценить стиль подачи материала, понять, подходит ли вам программирование, и освоить начальные основы Python. Полная версия курса с дополнительными материалами доступна на образовательной платформе по ссылке в описании.
</p>
<h2 id="12-основы-программирования-мифы-и-реальность">
 1.2. Основы программирования: мифы и реальность
</h2>
<p>
 Если вы никогда раньше не занимались программированием, забудьте о стереотипах, которые могли видеть в фильмах. Программист умеет переустанавливать Windows не потому, что он программист, а потому что он прочитал документацию или посмотрел видеоинструкцию.
</p>
<p>
 Процесс написания кода происходит в специализированных текстовых редакторах. Программист работает с файлами, которые, по сути, являются обычными текстовыми документами. В них записываются ключевые слова и конструкции, соответствующие правилам определенного языка программирования.
</p>
<blockquote>
 <p>
  <strong>
   Синтаксис (Syntax)
  </strong>
  — это набор правил, который определяет, как должны быть написаны и структурированы команды и выражения в конкретном языке программирования. Корректный синтаксис позволяет компьютеру правильно понять и выполнить написанный код.
 </p>
</blockquote>
<p>
 Используя синтаксис, программист описывает логику работы программы — последовательность действий, которые должен выполнить компьютер.
</p>
<h3 id="типы-языков-программирования">
 Типы языков программирования
</h3>
<p>
 Существует множество языков программирования, но все их можно условно разделить на две большие категории: компилируемые и интерпретируемые.
</p>
<h4 id="компилируемые-языки">
 Компилируемые языки
</h4>
<p>
 В компилируемых языках процесс создания работающей программы состоит из двух этапов:
</p>
<ol>
 <li>
  <strong>
   Написание кода:
  </strong>
  Программист пишет исходный код в текстовых файлах. Этот код понятен человеку, но не компьютеру.
 </li>
 <li>
  <strong>
   Компиляция:
  </strong>
  После написания кода запускается специальная программа —
  <strong>
   компилятор
  </strong>
  . Она преобразует весь исходный код в
  <strong>
   машинный код
  </strong>
  — набор инструкций, понятных процессору и операционной системе. В результате получаются исполняемые файлы (например, с расширением
  <code>
   .exe
  </code>
  или
  <code>
   .dll
  </code>
  в Windows).
 </li>
 <li>
  <strong>
   Запуск:
  </strong>
  Только после завершения компиляции готовую программу можно запустить.
 </li>
</ol>
<p>
 Примеры компилируемых языков: C, C++, Rust, Go.
</p>
<blockquote>
 <p>
  <strong>
   Компилятор (Compiler)
  </strong>
  — это программа, которая переводит исходный код, написанный на языке программирования высокого уровня, в эквивалентный ему машинный код. Этот процесс выполняется однократно перед запуском программы.
 </p>
</blockquote>
<blockquote>
 <p>
  <strong>
   Машинный код (Machine Code)
  </strong>
  — это система команд в двоичном формате, которую центральный процессор компьютера может выполнять напрямую. Это самый низкий уровень представления программного кода.
 </p>
</blockquote>
<h4 id="интерпретируемые-языки">
 Интерпретируемые языки
</h4>
<p>
 Python относится к интерпретируемым языкам. Процесс работы с ними выглядит иначе:
</p>
<ol>
 <li>
  <strong>
   Написание кода:
  </strong>
  Код так же пишется в текстовых файлах.
 </li>
 <li>
  <strong>
   Интерпретация и выполнение:
  </strong>
  Вместо компилятора используется
  <strong>
   интерпретатор
  </strong>
  . Эта программа не создает отдельный исполняемый файл, а читает исходный код
  <strong>
   построчно
  </strong>
  и сразу же выполняет каждую команду. Стадия предварительной компиляции отсутствует.
 </li>
</ol>
<p>
 Такой подход значительно ускоряет разработку, так как позволяет мгновенно проверять работоспособность кода без ожидания компиляции всего проекта.
</p>
<p>
 Примеры интерпретируемых языков: Python, JavaScript, Ruby.
</p>
<blockquote>
 <p>
  <strong>
   Интерпретатор (Interpreter)
  </strong>
  — это программа, которая выполняет исходный код напрямую, анализируя и исполняя каждую инструкцию последовательно. В отличие от компилятора, интерпретатор не создает отдельный исполняемый файл.
 </p>
</blockquote>
<p>
 Разница в подходе обусловлена спецификой применения языков. Для системных компонентов, таких как драйверы, важна максимальная производительность, поэтому используется компиляция. Для веб-приложений или скриптов автоматизации важнее скорость разработки, поэтому предпочтительнее интерпретация.
</p>
<h2 id="13-python-в-деиствии-практические-примеры">
 1.3. Python в действии: Практические примеры
</h2>
<p>
 Современное программирование редко подразумевает написание всего кода с нуля. Главный принцип —
 <strong>
  не повторяться (Don't Repeat Yourself, DRY)
 </strong>
 . Большинство типовых задач уже решены, и для них существуют готовые компоненты —
 <strong>
  библиотеки
 </strong>
 .
</p>
<blockquote>
 <p>
  <strong>
   Библиотека (в программировании) (Library)
  </strong>
  — это набор готового кода (функций, классов, модулей), который можно использовать в своих программах для решения определенных задач. Библиотеки позволяют не писать стандартный функционал с нуля, значительно ускоряя разработку.
 </p>
</blockquote>
<p>
 Инфраструктура библиотек в Python развита лучше, чем в любом другом языке, что является одной из ключевых причин его популярности.
</p>
<h3 id="пример-1-автоматическии-сбор-данных-парсинг">
 Пример 1: Автоматический сбор данных (Парсинг)
</h3>
<p>
 <strong>
  Задача:
 </strong>
 Собрать информацию о товарах с сайта интернет-магазина (названия, описания, цены, изображения) и сохранить ее в таблицу Excel.
</p>
<p>
 Вместо того чтобы писать с нуля код для отправки запросов в интернет, анализа HTML-страниц и работы с файлами Excel, мы можем подключить готовые библиотеки:
</p>
<ol>
 <li>
  <strong>
   Библиотека для веб-запросов и парсинга:
  </strong>
  Помогает загрузить страницу сайта и найти на ней нужные элементы (например,
  <code>
   requests
  </code>
  и
  <code>
   BeautifulSoup
  </code>
  ).
 </li>
 <li>
  <strong>
   Библиотека для работы с Excel:
  </strong>
  Позволяет создавать и записывать данные в файлы формата
  <code>
   .xlsx
  </code>
  (например,
  <code>
   openpyxl
  </code>
  ).
 </li>
</ol>
<p>
 Код такой программы будет состоять из двух небольших файлов:
</p>
<ul>
 <li>
  <strong>
   Первый файл:
  </strong>
  Описывает логику поиска данных на странице и загрузки изображений.
 </li>
 <li>
  <strong>
   Второй файл:
  </strong>
  Описывает процесс записи полученных данных в таблицу Excel.
 </li>
</ul>
<p>
 Поскольку такой программе не нужен графический интерфейс, она запускается через
 <strong>
  терминал
 </strong>
 (командную строку). Современные редакторы кода имеют встроенный терминал, что позволяет запустить скрипт нажатием одной кнопки. Программа автоматически выполнит все шаги и создаст на вашем компьютере Excel-файл с собранными данными и папку со скачанными изображениями.
</p>
<h3 id="пример-2-серверная-часть-веб-приложения">
 Пример 2: Серверная часть веб-приложения
</h3>
<p>
 <strong>
  Задача:
 </strong>
 Создать серверную часть (бэкенд) для интернет-магазина.
</p>
<p>
 Проект такого масштаба имеет более сложную структуру с множеством папок и файлов, отвечающих за разные части функционала (каталог товаров, корзина, регистрация пользователей и т.д.).
</p>
<p>
 Здесь также не нужно писать все с нуля. Для создания веб-приложений на Python существуют мощные
 <strong>
  фреймворки
 </strong>
 , такие как
 <strong>
  Django
 </strong>
 или
 <strong>
  Flask
 </strong>
 .
</p>
<blockquote>
 <p>
  <strong>
   Фреймворк (Framework)
  </strong>
  — это каркас или основа для создания приложений, который задает структуру проекта и предоставляет набор готовых инструментов для решения типовых задач (например, маршрутизация запросов, работа с базой данных, аутентификация). Программист дописывает только уникальную бизнес-логику своего приложения.
 </p>
</blockquote>
<p>
 Использование фреймворка значительно упрощает и ускоряет разработку. Программисту не нужно беспокоиться о низкоуровневых деталях, а можно сосредоточиться на реализации бизнес-логики магазина. Готовый проект загружается на сервер и запускается для обработки запросов от пользователей.
</p>
<h2 id="14-популярность-и-преимущества-python">
 1.4. Популярность и преимущества Python
</h2>
<p>
 Прежде чем изучать новую технологию, важно убедиться в ее актуальности.
</p>
<h3 id="статистика-и-реитинги">
 Статистика и рейтинги
</h3>
<ul>
 <li>
  <strong>
   TIOBE Index:
  </strong>
  Организация, постоянно отслеживающая популярность языков программирования, регулярно ставит Python на первое место.
 </li>
 <li>
  <strong>
   IEEE Spectrum (2024):
  </strong>
  Рейтинг от Института инженеров электротехники и электроники (IEEE) также показывает лидерство Python. В рейтинге
  <code>
   Jobs
  </code>
  , отражающем спрос работодателей, на первом месте находится
  <strong>
   SQL
  </strong>
  , однако Python занимает второе место среди языков программирования, что фактически делает его лидером.
 </li>
</ul>
<blockquote>
 <p>
  <strong>
   SQL (Structured Query Language)
  </strong>
  — это язык структурированных запросов, используемый для создания, изменения и извлечения данных из реляционных баз данных. Он не является языком программирования общего назначения и почти всегда используется в связке с такими языками, как Python, Java или JavaScript.
 </p>
</blockquote>
<h3 id="ключевые-особенности-языка">
 Ключевые особенности языка
</h3>
<ol>
 <li>
  <strong>
   Простой и лаконичный синтаксис:
  </strong>
  Python использует отступы для разделения блоков кода вместо скобок, что делает код очень читаемым.
 </li>
 <li>
  <strong>
   Низкий порог вхождения:
  </strong>
  Благодаря простоте синтаксиса, Python легко изучать с абсолютного нуля.
 </li>
 <li>
  <strong>
   Интерпретируемый язык:
  </strong>
  Ускоряет разработку, так как не требует этапа компиляции.
 </li>
 <li>
  <strong>
   Огромная экосистема:
  </strong>
  Широчайший выбор библиотек и фреймворков для любых задач.
 </li>
 <li>
  <strong>
   Многофункциональность:
  </strong>
  Python — язык общего (или многоцелевого) назначения, подходящий для решения самых разных проблем.
 </li>
 <li>
  <strong>
   Большое сообщество:
  </strong>
  Активное сообщество разработчиков способствует развитию языка, созданию новых инструментов и быстрой помощи в решении проблем.
 </li>
 <li>
  <strong>
   Автоматическое управление памятью:
  </strong>
  Программисту не нужно вручную выделять и освобождать память, что снижает риск ошибок, таких как утечки памяти, и ускоряет разработку.
 </li>
 <li>
  <strong>
   Объектно-ориентированный:
  </strong>
  Python полностью поддерживает объектно-ориентированную парадигму, что позволяет удобно моделировать сущности реального мира.
 </li>
 <li>
  <strong>
   Сильная динамическая типизация:
  </strong>
  <ul>
   <li>
    <strong>
     Динамическая:
    </strong>
    Тип переменной определяется автоматически во время выполнения программы, что делает код более гибким и менее многословным.
   </li>
   <li>
    <strong>
     Сильная:
    </strong>
    Не позволяет выполнять операции над несовместимыми типами данных (например, сложить число и строку), что делает код более безопасным и предсказуемым.
   </li>
  </ul>
 </li>
 <li>
  <strong>
   Кроссплатформенность:
  </strong>
  Программы на Python работают без изменений на Windows, macOS, Linux и других операционных системах.
 </li>
</ol>
<h2 id="15-сферы-применения-python">
 1.5. Сферы применения Python
</h2>
<p>
 Python — многоцелевой язык, но, как и любой инструмент, он имеет свои сильные стороны.
</p>
<h3 id="основные-сферы-применения">
 Основные сферы применения
</h3>
<ul>
 <li>
  <strong>
   Веб-разработка (Backend):
  </strong>
  Создание серверной логики для веб-сайтов, API и веб-сервисов. Python отвечает за обработку запросов, работу с базами данных, аутентификацию и реализацию бизнес-логики.
  <em>
   Пример: Instagram, Spotify, Dropbox.
  </em>
 </li>
 <li>
  <strong>
   Анализ данных и научные вычисления:
  </strong>
  Обработка и визуализация больших объемов данных, статистический анализ, финансовое моделирование. Библиотеки, такие как
  <code>
   Pandas
  </code>
  ,
  <code>
   NumPy
  </code>
  и
  <code>
   Matplotlib
  </code>
  , сделали Python стандартом в этой области.
 </li>
 <li>
  <strong>
   Искусственный интеллект (ИИ), машинное обучение (ML) и нейросети:
  </strong>
  Это одна из ключевых областей для Python.
  <ul>
   <li>
    <strong>
     Искусственный интеллект (ИИ):
    </strong>
    Общая область, создающая системы, способные выполнять задачи, требующие человеческого интеллекта.
   </li>
   <li>
    <strong>
     Машинное обучение (ML):
    </strong>
    Подотрасль ИИ, где алгоритмы обучаются на данных для выполнения предсказаний или принятия решений (например, предсказание спроса, фильтрация спама).
   </li>
   <li>
    <strong>
     Нейросети:
    </strong>
    Один из методов машинного обучения, имитирующий работу человеческого мозга. Используется для сложных задач, таких как распознавание изображений (
    <code>
     Stable Diffusion
    </code>
    ) или обработка естественного языка (
    <code>
     ChatGPT
    </code>
    ).
   </li>
  </ul>
 </li>
 <li>
  <strong>
   Автоматизация задач (скриптинг):
  </strong>
  Написание небольших программ для автоматизации рутинных задач: работа с файлами (Word, Excel, PDF), массовая обработка изображений, парсинг сайтов, генерация отчетов.
 </li>
 <li>
  <strong>
   Кибербезопасность и тестирование (Pentesting):
  </strong>
  Анализ безопасности приложений, поиск уязвимостей, автоматизация тестирования.
 </li>
 <li>
  <strong>
   Системное администрирование и DevOps:
  </strong>
  Автоматизация развертывания приложений, управления серверами и конфигурациями.
 </li>
 <li>
  <strong>
   Интернет вещей (IoT):
  </strong>
  Программирование устройств, таких как умный дом, промышленные датчики и носимая электроника.
 </li>
 <li>
  <strong>
   Прототипирование:
  </strong>
  Быстрое создание рабочих прототипов для проверки идей и демонстрации инвесторам.
 </li>
</ul>
<h3 id="где-python-используется-но-не-является-лидером">
 Где Python используется, но не является лидером
</h3>
<ul>
 <li>
  <strong>
   Десктопные приложения:
  </strong>
  На Python можно создавать приложения с графическим интерфейсом, но для этого существуют более специализированные и производительные решения (например, C# для Windows, Swift для macOS).
 </li>
 <li>
  <strong>
   Мобильные приложения (Android/iOS):
  </strong>
  Хотя существуют инструменты для создания мобильных приложений на Python, нативными языками являются Kotlin (для Android) и Swift (для iOS), которые обеспечивают лучшую производительность и интеграцию с ОС.
 </li>
 <li>
  <strong>
   Разработка игр (Gamedev):
  </strong>
  Python используется для написания скриптов в некоторых игровых движках (например, в
  <em>
   World of Tanks
  </em>
  ) и для создания простых 2D-игр. Однако индустриальным стандартом для крупных проектов являются движки Unity (C#) и Unreal Engine (C++).
 </li>
</ul>
<h2 id="16-организационные-моменты-и-подготовка-к-курсу">
 1.6. Организационные моменты и подготовка к курсу
</h2>
<ul>
 <li>
  <strong>
   Начальные знания:
  </strong>
  Не требуются. Курс разработан для изучения с абсолютного нуля.
 </li>
 <li>
  <strong>
   Компьютер:
  </strong>
  Подойдет любой современный компьютер или ноутбук. Мощное "железо" не нужно.
 </li>
 <li>
  <strong>
   Операционная система:
  </strong>
  Любая из популярных — Windows, macOS или Linux.
 </li>
 <li>
  <strong>
   Знание английского языка:
  </strong>
  Для прохождения курса не требуется. Однако для профессиональной работы в IT технический английский будет необходим (он осваивается в процессе практики).
 </li>
 <li>
  <strong>
   Знание математики:
  </strong>
  Глубокие знания математики требуются только в узкоспециализированных областях (анализ данных, инженерия). Для веб-разработки или автоматизации достаточно базовой школьной арифметики.
 </li>
 <li>
  <strong>
   "Я гуманитарий":
  </strong>
  Мышление программиста — это навык, который развивается с практикой, а не врожденный талант. Не переживайте, если что-то не получается с первого раза — это нормально.
 </li>
 <li>
  <strong>
   Дополнительные материалы:
  </strong>
  Все шпаргалки, исходный код и практические задания будут доступны для скачивания.
 </li>
 <li>
  <strong>
   Вопросы и обратная связь:
  </strong>
  Не стесняйтесь задавать вопросы в комментариях или в разделе "Вопросы и ответы" под лекциями. Обсуждение помогает лучше усвоить материал.
 </li>
</ul>
<h2 id="17-введение-в-работу-с-терминалом">
 1.7. Введение в работу с терминалом
</h2>
<p>
 Прежде чем устанавливать Python, необходимо познакомиться с терминалом — мощным инструментом для взаимодействия с компьютером.
</p>
<h3 id="что-такое-терминал-и-для-чего-он-нужен">
 Что такое терминал и для чего он нужен?
</h3>
<p>
 Существует три основных способа взаимодействия с операционной системой и программами:
</p>
<ol>
 <li>
  <strong>
   GUI (Graphical User Interface):
  </strong>
  Графический пользовательский интерфейс. Это привычные нам окна, кнопки и иконки, с которыми мы работаем при помощи мыши.
 </li>
 <li>
  <strong>
   CLI (Command-Line Interface):
  </strong>
  Интерфейс командной строки. Взаимодействие происходит путем ввода текстовых команд в специальной программе —
  <strong>
   терминале
  </strong>
  .
 </li>
 <li>
  <strong>
   API (Application Programming Interface):
  </strong>
  Программный интерфейс. Позволяет программам "общаться" друг с другом без участия человека.
 </li>
</ol>
<blockquote>
 <p>
  <strong>
   Операционная система (ОС)
  </strong>
  — это комплекс программного обеспечения, управляющий аппаратными ресурсами компьютера и предоставляющий базовые сервисы для работы других программ. Примеры: Windows, macOS, Linux.
 </p>
</blockquote>
<blockquote>
 <p>
  <strong>
   Терминал (Terminal)
  </strong>
  — это программа, которая предоставляет текстовый интерфейс для взаимодействия с операционной системой. Пользователь вводит команды с клавиатуры и получает ответ в виде текста.
 </p>
</blockquote>
<p>
 Через терминал можно выполнять все те же действия, что и через графический интерфейс (создавать папки, запускать программы), а также многие другие, для которых графический интерфейс не предусмотрен.
</p>
<h3 id="оболочка-shell-и-терминал-в-чем-разница">
 Оболочка (Shell) и Терминал: в чем разница?
</h3>
<p>
 Важно различать два понятия:
</p>
<ul>
 <li>
  <strong>
   Терминал:
  </strong>
  Это сама программа-“окошко”, в которое вы вводите текст.
 </li>
 <li>
  <strong>
   Оболочка (Shell):
  </strong>
  Это программа, которая работает
  <em>
   внутри
  </em>
  терминала. Она интерпретирует ваши команды и передает их на выполнение ядру операционной системы.
 </li>
</ul>
<blockquote>
 <p>
  <strong>
   Оболочка (Shell)
  </strong>
  — это интерпретатор команд, который выступает в роли посредника между пользователем и ядром операционной системы. Разные оболочки имеют свой синтаксис и набор команд.
 </p>
</blockquote>
<p>
 Основные оболочки в разных ОС:
</p>
<ul>
 <li>
  <strong>
   Windows:
  </strong>
  <code>
   CMD
  </code>
  (Command Prompt, старая) и
  <code>
   PowerShell
  </code>
  (более новая и мощная).
 </li>
 <li>
  <strong>
   Linux:
  </strong>
  <code>
   Bash
  </code>
  (самая распространенная),
  <code>
   sh
  </code>
  .
 </li>
 <li>
  <strong>
   macOS:
  </strong>
  <code>
   Zsh
  </code>
  (по умолчанию в новых версиях),
  <code>
   Bash
  </code>
  .
 </li>
</ul>
<p>
 Когда говорят "терминал PowerShell" или "терминал Bash", имеют в виду, какая оболочка запущена в окне терминала, так как именно она определяет доступные команды.
</p>
<h3 id="основные-команды-и-концепции">
 Основные команды и концепции
</h3>
<p>
 Работа в терминале всегда происходит в контексте определенной папки (директории). Это называется
 <strong>
  текущая рабочая директория
 </strong>
 .
</p>
<blockquote>
 <p>
  <strong>
   Файловая система (File System)
  </strong>
  — это способ организации и хранения файлов и папок на носителе информации (жестком диске, SSD). Она определяет структуру каталогов и правила именования файлов.
 </p>
</blockquote>
<p>
 <strong>
  Ключевое различие в файловых системах:
 </strong>
</p>
<ul>
 <li>
  <strong>
   Windows:
  </strong>
  Пути начинаются с буквы диска (например,
  <code>
   C:\Users\Имя_пользователя
  </code>
  ).
 </li>
 <li>
  <strong>
   Linux и macOS:
  </strong>
  Единая корневая директория
  <code>
   /
  </code>
  . Дисков в привычном понимании нет (например,
  <code>
   /home/имя_пользователя
  </code>
  ).
 </li>
</ul>
<p>
 <strong>
  Базовые команды (работают в PowerShell, Bash, Zsh):
 </strong>
</p>
<table>
 <thead>
  <tr>
   <th style="text-align:left;">
    Команда
   </th>
   <th style="text-align:left;">
    Описание
   </th>
   <th style="text-align:left;">
    Пример (Linux/macOS)
   </th>
   <th style="text-align:left;">
    Пример (Windows)
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td style="text-align:left;">
    <code>
     pwd
    </code>
   </td>
   <td style="text-align:left;">
    Показать текущую рабочую директорию
   </td>
   <td style="text-align:left;">
    <code>
     pwd
    </code>
   </td>
   <td style="text-align:left;">
    <code>
     pwd
    </code>
   </td>
  </tr>
  <tr>
   <td style="text-align:left;">
    <code>
     ls
    </code>
   </td>
   <td style="text-align:left;">
    Показать содержимое текущей директории
   </td>
   <td style="text-align:left;">
    <code>
     ls
    </code>
   </td>
   <td style="text-align:left;">
    <code>
     ls
    </code>
   </td>
  </tr>
  <tr>
   <td style="text-align:left;">
    <code>
     cd
    </code>
   </td>
   <td style="text-align:left;">
    Сменить директорию (Change Directory)
   </td>
   <td style="text-align:left;">
    <code>
     cd Documents
    </code>
   </td>
   <td style="text-align:left;">
    <code>
     cd Documents
    </code>
   </td>
  </tr>
  <tr>
   <td style="text-align:left;">
    <code>
     cd ..
    </code>
   </td>
   <td style="text-align:left;">
    Перейти на уровень выше
   </td>
   <td style="text-align:left;">
    <code>
     cd ..
    </code>
   </td>
   <td style="text-align:left;">
    <code>
     cd ..
    </code>
   </td>
  </tr>
  <tr>
   <td style="text-align:left;">
    <code>
     clear
    </code>
   </td>
   <td style="text-align:left;">
    Очистить экран терминала
   </td>
   <td style="text-align:left;">
    <code>
     clear
    </code>
   </td>
   <td style="text-align:left;">
    <code>
     clear
    </code>
    или
    <code>
     cls
    </code>
   </td>
  </tr>
 </tbody>
</table>
<p>
 <strong>
  Запуск программ и открытие файлов:
 </strong>
</p>
<p>
 Чтобы запустить программу или открыть файл, нужно указать либо ее имя (если система знает, где она находится), либо полный путь к ней.
</p>
<ul>
 <li>
  <strong>
   На Windows:
  </strong>
  <code>
   start имя_файла.txt
  </code>
 </li>
 <li>
  <strong>
   На macOS:
  </strong>
  <code>
   open имя_файла.txt
  </code>
 </li>
 <li>
  <strong>
   На Linux:
  </strong>
  <code>
   xdg-open имя_файла.txt
  </code>
 </li>
</ul>
<h3 id="переменные-среды-и-path">
 Переменные среды и PATH
</h3>
<p>
 Как оболочка находит программы (например,
 <code>
  ping
 </code>
 ), когда мы вводим их имя без указания полного пути? Для этого существует специальная
 <strong>
  переменная среды
 </strong>
 под названием
 <code>
  PATH
 </code>
 .
</p>
<blockquote>
 <p>
  <strong>
   Переменная среды (Environment Variable)
  </strong>
  — это именованное значение, которое хранится на уровне операционной системы и может влиять на поведение запущенных процессов. Программы могут считывать эти переменные для своей конфигурации.
 </p>
</blockquote>
<p>
 Переменная
 <code>
  PATH
 </code>
 содержит список путей к папкам, в которых система будет искать исполняемые файлы. Когда вы вводите команду, оболочка последовательно проверяет все папки из
 <code>
  PATH
 </code>
 , и если находит файл с таким именем, запускает его. Именно поэтому при установке Python важно добавить его в
 <code>
  PATH
 </code>
 , чтобы можно было запускать интерпретатор командой
 <code>
  python
 </code>
 из любой директории.
</p>
<h2 id="18-установка-python-и-управление-версиями">
 1.8. Установка Python и управление версиями
</h2>
<p>
 Для работы с Python необходимо установить его официальный интерпретатор с сайта
 <strong>
  python.org
 </strong>
 .
</p>
<h3 id="загрузка-и-установка">
 Загрузка и установка
</h3>
<ol>
 <li>
  Перейдите на сайт
  <a href="https://python.org">
   python.org
  </a>
  .
 </li>
 <li>
  Откройте раздел
  <strong>
   Downloads
  </strong>
  .
 </li>
 <li>
  Сайт автоматически определит вашу операционную систему и предложит скачать последнюю стабильную версию.
 </li>
</ol>
<p>
 Процесс установки имеет свои нюансы для каждой ОС, которые будут рассмотрены в отдельных инструкциях.
 <strong>
  Ключевой момент при установке на Windows — не забудьте поставить галочку "Add Python to PATH"
 </strong>
 .
</p>
<h3 id="понимание-версии-python">
 Понимание версий Python
</h3>
<p>
 Версия Python обычно записывается тремя числами, например,
 <code>
  3.12.1
 </code>
 .
</p>
<ul>
 <li>
  <strong>
   3 (Major):
  </strong>
  Основная, или мажорная, версия. Крупные изменения, которые могут нарушать обратную совместимость. Код, написанный для Python 2, не будет работать на Python 3.
 </li>
 <li>
  <strong>
   12 (Minor):
  </strong>
  Минорная версия. Добавление нового функционала без нарушения совместимости. Код, написанный для Python 3.8, будет работать на Python 3.12.
 </li>
 <li>
  <strong>
   1 (Patch):
  </strong>
  Патч-версия. Исправление ошибок. Не добавляет новых функций.
 </li>
</ul>
<p>
 <strong>
  Для изучения языка:
 </strong>
 Если вы изучаете Python 3, не имеет значения, какая у вас минорная версия — 3.10, 3.12 или 3.20. Все основные концепции и синтаксис остаются неизменными. Новые версии лишь добавляют дополнительные возможности.
</p>
<h3 id="семантическое-версионирование-semver">
 Семантическое версионирование (SemVer)
</h3>
<p>
 В профессиональной разработке для управления версиями программного обеспечения часто используется стандарт
 <strong>
  Семантическое версионирование (SemVer)
 </strong>
 . Он помогает разработчикам понимать, как изменения в версии влияют на совместимость кода.
</p>
<blockquote>
 <p>
  <strong>
   Семантическое версионирование (Semantic Versioning)
  </strong>
  — это формализованный стандарт управления версиями ПО в формате
  <code>
   MAJOR.MINOR.PATCH
  </code>
  . Он предписывает изменять MAJOR-версию при несовместимых изменениях, MINOR-версию при добавлении нового функционала с сохранением совместимости, и PATCH-версию при исправлении ошибок.
 </p>
</blockquote>
<p>
 Принцип версионирования Python очень похож на SemVer, но имеет свои исторические особенности. Понимание этого стандарта полезно для любого разработчика, так как он широко применяется в экосистеме библиотек и фреймворков.
</p>
<p>
 На этом теоретическое введение завершено. В следующих разделах мы перейдем к установке необходимого программного обеспечения и начнем писать наш первый код на Python.
</p>
<h1 id="глава-1-введение-в-python-и-основы-программирования-продолжение">
 Глава 1: Введение в Python и основы программирования (продолжение)
</h1>
<h2 id="19-глубокии-взгляд-на-версии-python-semver-и-реальность">
 1.9. Глубокий взгляд на версии Python: SemVer и реальность
</h2>
<p>
 В предыдущем разделе мы кратко коснулись системы версионирования Python. Теперь давайте разберем эту тему более детально, так как понимание версий имеет ключевое значение в профессиональной разработке. Хотя система версионирования Python похожа на общепринятый стандарт
 <strong>
  SemVer
 </strong>
 , у нее есть важные особенности.
</p>
<h3 id="191-особенности-версионирования-в-python">
 1.9.1. Особенности версионирования в Python
</h3>
<p>
 Давайте вспомним структуру версии
 <code>
  MAJOR.MINOR.PATCH
 </code>
 (Основная.Минорная.Патч):
</p>
<ul>
 <li>
  <strong>
   MAJOR (Основная версия):
  </strong>
  Изменяется крайне редко (раз в 10-20 лет) и означает глобальные изменения, нарушающие обратную совместимость. Код, написанный на Python 2, несовместим с Python 3.
 </li>
 <li>
  <strong>
   MINOR (Минорная версия):
  </strong>
  Выпускается примерно раз в год. В минорную версию добавляется новый функционал. В теории, она должна сохранять обратную совместимость, но в Python это не всегда так.
 </li>
 <li>
  <strong>
   PATCH (Патч-версия):
  </strong>
  Исправляет ошибки (баги) и уязвимости безопасности. Не добавляет новых функций и полностью совместима в рамках одной минорной версии.
 </li>
</ul>
<blockquote>
 <p>
  <strong>
   Обратная совместимость (Backward Compatibility)
  </strong>
  — это свойство новой версии программного обеспечения поддерживать форматы данных или код, созданные в более старых версиях. Это позволяет программам и проектам безболезненно обновляться.
 </p>
</blockquote>
<p>
 Если в чистом SemVer обновление минорной версии гарантирует, что старый код будет работать без изменений, то в Python это требует проверки. Минорные версии могут вносить изменения в стандартные библиотеки, которые нарушают совместимость с кодом, написанным для предыдущих минорных версий.
</p>
<p>
 Это не затрагивает базовый синтаксис языка, который вы изучаете, но может повлиять на работу больших проектов, использующих специфические функции стандартных библиотек. Поэтому в экосистеме Python принято рассматривать
 <strong>
  каждую минорную версию как отдельную, полумажорную ветку разработки.
 </strong>
</p>
<blockquote>
 <p>
  <strong>
   Ветка (Branch)
  </strong>
  — в контексте разработки ПО это направление развития проекта, которое существует параллельно с другими. Например, для версии Python 3.12 существует своя ветка, в которую вносят исправления, в то время как уже активно разрабатывается ветка 3.13.
 </p>
</blockquote>
<h3 id="192-жизненныи-цикл-минорных-версии">
 1.9.2. Жизненный цикл минорных версий
</h3>
<p>
 Каждая минорная версия Python имеет длительный срок поддержки (около 5 лет), который делится на несколько этапов. Это позволяет проектам стабильно работать годами на одной версии, получая необходимые обновления.
</p>
<p>
 Вы можете отслеживать статус всех версий на официальном сайте в разделе "Active Python Releases". Этапы поддержки:
</p>
<ol>
 <li>
  <strong>
   Bugfix (Исправление ошибок):
  </strong>
  Первые ~1.5 года после релиза. Версия получает как исправления ошибок, так и обновления безопасности. Новые проекты рекомендуется начинать на последней версии, находящейся на этом этапе.
 </li>
 <li>
  <strong>
   Security (Только безопасность):
  </strong>
  Следующие ~3.5 года. Версия больше не получает исправлений обычных ошибок, но для нее продолжают выпускать патчи, закрывающие критические уязвимости.
 </li>
 <li>
  <strong>
   End of life (Окончание поддержки):
  </strong>
  По истечении 5 лет поддержка версии полностью прекращается.
 </li>
</ol>
<p>
 Например, если проект был начат на Python 3.11, он будет получать обновления безопасности вплоть до 2026 года. Это дает разработчикам достаточно времени, чтобы спокойно спланировать и осуществить переход на более новую минорную версию (например, 3.13), внеся необходимые изменения, если они затронули проект.
</p>
<h3 id="193-резюме-по-версиям-python">
 1.9.3. Резюме по версиям Python
</h3>
<ul>
 <li>
  <strong>
   Смена MAJOR-версии (2 -&gt; 3):
  </strong>
  Редкость. Синтаксис меняется незначительно, но проекты требуют адаптации.
 </li>
 <li>
  <strong>
   Смена MINOR-версии (3.12 -&gt; 3.13):
  </strong>
  <ul>
   <li>
    Сам синтаксис языка для изучающего не меняется.
   </li>
   <li>
    Добавляются новые возможности.
   </li>
   <li>
    Для реальных проектов нужно проверять
    <strong>
     заметки к релизу (release notes)
    </strong>
    , чтобы узнать, не затронули ли изменения используемые библиотеки.
   </li>
   <li>
    Каждая минорная версия поддерживается годами как отдельная ветка.
   </li>
  </ul>
 </li>
 <li>
  <strong>
   Смена PATCH-версии (3.12.8 -&gt; 3.12.9):
  </strong>
  <ul>
   <li>
    Полностью безопасно. Исправляются только ошибки и уязвимости.
   </li>
   <li>
    Новый функционал не добавляется.
   </li>
  </ul>
 </li>
</ul>
<p>
 Для обучения всегда скачивайте и используйте самую последнюю стабильную версию Python. Это позволит вам работать с самыми современными возможностями языка.
</p>
<h2 id="110-установка-python-руководство-для-разных-ос">
 1.10. Установка Python: Руководство для разных ОС
</h2>
<p>
 Теперь перейдем к практике. Мы установим последнюю версию Python и все необходимые инструменты.
</p>
<h3 id="1101-скачивание-определеннои-версии">
 1.10.1. Скачивание определенной версии
</h3>
<p>
 Если вам по какой-то причине нужна не последняя, а конкретная версия Python (например, 3.8 для Windows 7 или версия, требуемая проектом), выполните следующие шаги:
</p>
<ol>
 <li>
  Перейдите на сайт
  <a href="https://python.org">
   python.org
  </a>
  в раздел
  <strong>
   Downloads
  </strong>
  .
 </li>
 <li>
  Выберите вашу операционную систему (Windows, macOS, Linux).
 </li>
 <li>
  Найдите заголовок "Looking for a specific release?" или "Stable Releases".
 </li>
 <li>
  В списке выберите нужную версию (например, Python 3.12.9).
 </li>
 <li>
  На странице релиза найдите таблицу "Files" и скачайте нужный установщик (например, "Windows installer (64-bit)").
 </li>
</ol>
<p>
 <strong>
  Особые случаи:
 </strong>
</p>
<ul>
 <li>
  <strong>
   Windows 7:
  </strong>
  Последняя поддерживаемая версия —
  <strong>
   Python 3.8
  </strong>
  .
 </li>
 <li>
  <strong>
   ARM-процессоры (Snapdragon, Apple Silicon):
  </strong>
  Убедитесь, что скачиваете версию для архитектуры
  <strong>
   ARM64
  </strong>
  .
 </li>
</ul>
<h3 id="1102-альтернативные-способы-работы-с-python-без-установки">
 1.10.2. Альтернативные способы работы с Python (без установки)
</h3>
<p>
 Иногда нет доступа к своему компьютеру, но прерывать обучение не хочется. В таких случаях можно использовать онлайн-инструменты, которые позволяют писать и выполнять код прямо в браузере.
</p>
<ul>
 <li>
  <strong>
   Онлайн-интерпретаторы:
  </strong>
  Просто введите в поиске "Python online". Множество сайтов (Programiz, Replit и др.) предоставляют простой интерфейс, где можно написать код и сразу увидеть результат.
 </li>
 <li>
  <strong>
   Google Colaboratory:
  </strong>
  Более мощный инструмент от Google. Перейдите на Google Диск, нажмите "Создать" -&gt; "Еще" -&gt; "Подключить другие приложения" и найдите
  <code>
   Google Colaboratory
  </code>
  . После установки вы сможете создавать "блокноты" — интерактивные документы, где можно писать и выполнять код Python по частям.
 </li>
</ul>
<blockquote>
 <p>
  <strong>
   Интерактивный режим (Interactive Mode)
  </strong>
  — это способ работы с интерпретатором, при котором вы вводите команды по одной, и система сразу же выполняет их и показывает результат. Это удобно для быстрых тестов и экспериментов.
 </p>
</blockquote>
<p>
 Эти варианты отлично подходят для временного использования, но для полноценного обучения и работы мы настоятельно рекомендуем установить Python на ваш компьютер.
</p>
<h3 id="1103-установка-на-windows">
 1.10.3. Установка на Windows
</h3>
<ol>
 <li>
  Запустите скачанный
  <code>
   .exe
  </code>
  файл установщика.
 </li>
 <li>
  <strong>
   Важнейший шаг:
  </strong>
  В первом окне обязательно поставьте галочку
  <strong>
   <code>
    Add python.exe to PATH
   </code>
  </strong>
  . Это позволит запускать Python из терминала командой
  <code>
   python
  </code>
  из любой папки.
 </li>
 <li>
  Если вы — единственный пользователь компьютера с правами администратора, поставьте галочку
  <strong>
   <code>
    Use admin privileges when installing py.exe
   </code>
  </strong>
  .
 </li>
 <li>
  Выберите
  <strong>
   <code>
    Customize installation
   </code>
  </strong>
  для профессиональной установки.
 </li>
 <li>
  На следующем экране ("Optional Features") убедитесь, что все галочки установлены, и нажмите
  <strong>
   Next
  </strong>
  .
 </li>
 <li>
  На экране "Advanced Options":
  <ul>
   <li>
    Поставьте галочку
    <strong>
     <code>
      Install for all users
     </code>
    </strong>
    . Путь установки изменится на
    <code>
     C:\Program Files\Python313
    </code>
    .
   </li>
   <li>
    <strong>
     Измените путь установки.
    </strong>
    <code>
     Program Files
    </code>
    — защищенная системная папка. Создайте на диске
    <code>
     C:
    </code>
    новую папку (например,
    <code>
     Python313
    </code>
    ) и укажите путь к ней через кнопку
    <strong>
     <code>
      Browse
     </code>
    </strong>
    . Это предотвратит возможные проблемы с правами доступа.
   </li>
   <li>
    Остальные галочки (
    <code>
     Associate files...
    </code>
    ,
    <code>
     Create shortcuts...
    </code>
    ,
    <code>
     Add Python to environment variables
    </code>
    ) оставьте включенными.
   </li>
   <li>
    Галочки, связанные с
    <code>
     debugging symbols
    </code>
    и
    <code>
     free-threaded binaries
    </code>
    (экспериментальная функция),
    <strong>
     не ставьте
    </strong>
    .
   </li>
  </ul>
 </li>
 <li>
  Нажмите
  <strong>
   Install
  </strong>
  .
 </li>
 <li>
  После завершения установки может появиться окно с опцией
  <strong>
   <code>
    Disable path length limit
   </code>
  </strong>
  . Нажмите на нее, чтобы снять ограничение Windows на длину путей в переменной
  <code>
   PATH
  </code>
  .
 </li>
 <li>
  Перезагрузите компьютер.
 </li>
</ol>
<p>
 <strong>
  Проверка установки:
 </strong>
 Откройте PowerShell или Командную строку и введите команду
 <code>
  python
 </code>
 . Вы должны увидеть приветствие интерпретатора Python с указанием его версии. Это интерактивный режим. Для выхода введите
 <code>
  exit()
 </code>
 или
 <code>
  quit()
 </code>
 и нажмите Enter.
</p>
<h3 id="1104-установка-на-macos">
 1.10.4. Установка на macOS
</h3>
<p>
 В macOS уже предустановлен системный Python, который используется самой ОС. Мы установим новую версию параллельно, не затрагивая системную.
</p>
<ol>
 <li>
  Запустите скачанный
  <code>
   .pkg
  </code>
  файл.
 </li>
 <li>
  Следуйте инструкциям установщика, нажимая "Continue" и "Agree".
 </li>
 <li>
  На этапе "Installation Type" просто нажмите
  <strong>
   Install
  </strong>
  , не выбирая
  <code>
   Customize
  </code>
  . Установщик сам разместит файлы в нужных директориях, которые уже прописаны в
  <code>
   PATH
  </code>
  .
 </li>
 <li>
  После завершения установки откройте
  <strong>
   Finder
  </strong>
  -&gt;
  <strong>
   Программы (Applications)
  </strong>
  .
 </li>
 <li>
  Найдите папку с вашей версией Python (например,
  <code>
   Python 3.13
  </code>
  ).
 </li>
 <li>
  Внутри этой папки найдите и дважды кликните по файлу
  <strong>
   <code>
    Install Certificates.command
   </code>
  </strong>
  . Откроется окно терминала, которое автоматически выполнит скрипт установки SSL-сертификатов (необходимы для безопасной работы с интернетом). Дождитесь надписи
  <code>
   process completed
  </code>
  и закройте окно.
 </li>
 <li>
  Перезагрузите компьютер.
 </li>
</ol>
<p>
 <strong>
  Проверка установки:
 </strong>
 Откройте терминал. Важно: на macOS и Linux новая версия Python запускается командой
 <code>
  python3
 </code>
 , а не
 <code>
  python
 </code>
 . Введите
 <code>
  python3
 </code>
 . Вы должны увидеть приветствие интерпретатора с новой версией. Для выхода введите
 <code>
  exit()
 </code>
 или
 <code>
  quit()
 </code>
 .
</p>
<h3 id="1105-установка-на-linux-из-исходного-кода">
 1.10.5. Установка на Linux (из исходного кода)
</h3>
<p>
 На дистрибутивах Linux (например, Ubuntu) также есть системный Python. Самый надежный способ установить новую версию —
 <strong>
  скомпилировать ее из исходного кода
 </strong>
 . Это гарантирует, что мы не повредим системные файлы и получим чистую, оптимизированную установку.
</p>
<blockquote>
 <p>
  <strong>
   Исходный код (Source Code)
  </strong>
  — это текст программы, написанный на языке программирования, понятном человеку.
 </p>
 <p>
  <strong>
   Компиляция (Compilation)
  </strong>
  — это процесс преобразования исходного кода в машинный код (набор инструкций для процессора), который может быть выполнен компьютером.
 </p>
</blockquote>
<p>
 <strong>
  Процесс установки (для Ubuntu/Debian/Mint):
 </strong>
</p>
<ol>
 <li>
  <p>
   <strong>
    Скачайте архив с исходным кодом.
   </strong>
   На странице загрузки Python найдите файл с расширением
   <code>
    .tar.xz
   </code>
   (Gzipped source tarball) и скачайте его в свою домашнюю директорию (
   <code>
    /home/имя_пользователя
   </code>
   ).
  </p>
 </li>
 <li>
  <p>
   <strong>
    Установите зависимости.
   </strong>
   Откройте терминал и выполните команды для установки инструментов, необходимых для сборки:
  </p>
  <div class="codehilite">
   <pre><span></span><code>sudo<span class="w"> </span>apt<span class="w"> </span>update
sudo<span class="w"> </span>apt<span class="w"> </span>upgrade
sudo<span class="w"> </span>apt<span class="w"> </span>install<span class="w"> </span>build-essential<span class="w"> </span>zlib1g-dev<span class="w"> </span>libncurses5-dev<span class="w"> </span>libgdbm-dev<span class="w"> </span>libnss3-dev<span class="w"> </span>libssl-dev<span class="w"> </span>libreadline-dev<span class="w"> </span>libffi-dev<span class="w"> </span>libsqlite3-dev<span class="w"> </span>wget<span class="w"> </span>libbz2-dev
</code></pre>
  </div>
  <blockquote>
   <p>
    <strong>
     Репозиторий (Repository)
    </strong>
    — это централизованное хранилище, где хранятся пакеты программного обеспечения, из которого система может их устанавливать и обновлять.
    <code>
     apt update
    </code>
    обновляет список пакетов из репозиториев.
   </p>
  </blockquote>
 </li>
 <li>
  <p>
   <strong>
    Распакуйте архив.
   </strong>
   Вернитесь в домашнюю директорию и выполните команду (замените
   <code>
    X.Y.Z
   </code>
   на вашу версию):
  </p>
  <div class="codehilite">
   <pre><span></span><code>tar<span class="w"> </span>-xf<span class="w"> </span>Python-X.Y.Z.tar.xz
</code></pre>
  </div>
 </li>
 <li>
  <p>
   <strong>
    Перейдите в папку с исходниками:
   </strong>
  </p>
  <div class="codehilite">
   <pre><span></span><code><span class="nb">cd</span><span class="w"> </span>Python-X.Y.Z
</code></pre>
  </div>
 </li>
 <li>
  <p>
   <strong>
    Настройте сборку.
   </strong>
   Эта команда подготовит файлы к компиляции с включенной оптимизацией:
  </p>
  <div class="codehilite">
   <pre><span></span><code>./configure<span class="w"> </span>--enable-optimizations
</code></pre>
  </div>
 </li>
 <li>
  <p>
   <strong>
    Скомпилируйте Python.
   </strong>
   Эта команда запустит процесс компиляции.
   <code>
    -j 4
   </code>
   указывает использовать 4 потока процессора для ускорения. Можно указать 8 или просто
   <code>
    make
   </code>
   для одного потока. Процесс может занять от 2 до 20 минут.
  </p>
  <div class="codehilite">
   <pre><span></span><code>make<span class="w"> </span>-j<span class="w"> </span><span class="m">4</span>
</code></pre>
  </div>
 </li>
 <li>
  <p>
   <strong>
    Установите Python.
   </strong>
   Команда
   <code>
    altinstall
   </code>
   устанавливает новую версию параллельно системной, не перезаписывая ее.
  </p>
  <div class="codehilite">
   <pre><span></span><code>sudo<span class="w"> </span>make<span class="w"> </span>altinstall
</code></pre>
  </div>
 </li>
</ol>
<p>
 <strong>
  Проверка установки:
 </strong>
 Новая версия Python будет доступна по команде, включающей ее версию, например,
 <code>
  python3.13
 </code>
 . Введите эту команду в терминале, и вы должны увидеть интерактивный интерпретатор. Системный Python по-прежнему будет доступен по команде
 <code>
  python3
 </code>
 .
</p>
<h2 id="111-выполнение-кода-от-интерактивного-режима-до-скриптов">
 1.11. Выполнение кода: от интерактивного режима до скриптов
</h2>
<p>
 Интерпретатор Python может работать в двух основных режимах:
</p>
<ol>
 <li>
  <strong>
   Интерактивный режим:
  </strong>
  Вы запускаете
  <code>
   python
  </code>
  (или
  <code>
   python3
  </code>
  ) в терминале и вводите команды по одной, сразу получая результат. Идеально для быстрых вычислений и проверки небольших фрагментов кода.
 </li>
 <li>
  <strong>
   Исполнение из файла (скрипт):
  </strong>
  Вы пишете набор инструкций в текстовом файле с расширением
  <code>
   .py
  </code>
  и передаете этот файл интерпретатору для выполнения. Это основной способ создания программ.
 </li>
</ol>
<h3 id="1111-фаилы-с-кодом-и-важность-кодировки-utf-8">
 1.11.1. Файлы с кодом и важность кодировки UTF-8
</h3>
<p>
 Файл с кодом Python (например,
 <code>
  my_program.py
 </code>
 ) — это, по сути, обычный текстовый файл. Расширение
 <code>
  .py
 </code>
 лишь подсказывает операционной системе и редакторам, что внутри находится код на Python.
</p>
<p>
 Здесь возникает важный технический нюанс —
 <strong>
  кодировка текста
 </strong>
 .
</p>
<blockquote>
 <p>
  <strong>
   Кодировка (Encoding)
  </strong>
  — это набор правил, по которому символы текста (буквы, цифры, знаки) преобразуются в последовательность чисел (байт) для хранения в памяти компьютера. Существует множество кодировок (CP-1251, KOI8-R, UTF-16).
 </p>
 <p>
  <strong>
   UTF-8
  </strong>
  — это универсальный стандарт кодирования, который может представлять символы практически всех языков мира. Сегодня он является стандартом де-факто в вебе и разработке ПО.
 </p>
</blockquote>
<p>
 Python по умолчанию ожидает, что все файлы с кодом сохранены в кодировке
 <strong>
  UTF-8
 </strong>
 . Если файл будет сохранен в другой кодировке (что иногда случается в старых версиях Windows), интерпретатор не сможет его прочитать и выдаст ошибку.
</p>
<p>
 Современные редакторы кода и IDE (которые мы установим далее) автоматически создают файлы в нужной кодировке UTF-8, поэтому вам редко придется беспокоиться об этом.
</p>
<h3 id="1112-запуск-скрипта-из-терминала">
 1.11.2. Запуск скрипта из терминала
</h3>
<p>
 Чтобы выполнить код, записанный в файле, используйте терминал:
</p>
<ol>
 <li>
  Откройте терминал.
 </li>
 <li>
  С помощью команды
  <code>
   cd
  </code>
  перейдите в папку, где находится ваш
  <code>
   .py
  </code>
  файл.
 </li>
 <li>
  Выполните команду:
  <ul>
   <li>
    На Windows:
    <code>
     python имя_файла.py
    </code>
   </li>
   <li>
    На macOS/Linux:
    <code>
     python3 имя_файла.py
    </code>
    (или
    <code>
     python3.13 имя_файла.py
    </code>
    , если вы ставили конкретную версию).
   </li>
  </ul>
 </li>
</ol>
<p>
 Интерпретатор прочтет файл строка за строкой и выполнит все инструкции.
</p>
<h3 id="1113-разбор-примера-скрипт-автоматизации">
 1.11.3. Разбор примера: скрипт автоматизации
</h3>
<p>
 Давайте рассмотрим пример небольшого скрипта, который определяет операционную систему и запускает браузер и текстовый редактор. Это поможет визуализировать, как выглядит реальная программа.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Импортируем библиотеки для работы с ОС и системной информацией</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Автоматический запуск программ..."</span><span class="p">)</span>

<span class="c1"># Проверяем, является ли система Windows</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'win'</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">'start notepad.exe'</span><span class="p">)</span> <span class="c1"># Запускаем Блокнот</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">'start https://google.com'</span><span class="p">)</span> <span class="c1"># Открываем сайт в браузере</span>

<span class="c1"># Иначе, проверяем, является ли система macOS</span>
<span class="k">elif</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">'darwin'</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">'open -a TextEdit'</span><span class="p">)</span> <span class="c1"># Запускаем TextEdit</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">'open https://google.com'</span><span class="p">)</span>

<span class="c1"># Иначе, проверяем, является ли система Linux</span>
<span class="k">elif</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'linux'</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">'gedit &amp;'</span><span class="p">)</span> <span class="c1"># Запускаем Gedit</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">'xdg-open https://google.com &amp;'</span><span class="p">)</span>

<span class="c1"># Если ни одно из условий не выполнилось</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Неизвестная операционная система!"</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Программа завершена."</span><span class="p">)</span>
</code></pre>
</div>
<p>
 <strong>
  Что здесь происходит:
 </strong>
</p>
<ul>
 <li>
  <code>
   import os, sys
  </code>
  : Подключаем встроенные библиотеки.
  <code>
   os
  </code>
  — для взаимодействия с операционной системой (например, запуска команд),
  <code>
   sys
  </code>
  — для получения системной информации.
 </li>
 <li>
  <code>
   print(...)
  </code>
  : Выводим текст в терминал.
 </li>
 <li>
  <code>
   if / elif / else
  </code>
  : Это условные конструкции. Программа проверяет условия по очереди и выполняет только тот блок кода, чье условие оказалось истинным.
 </li>
 <li>
  <code>
   sys.platform
  </code>
  : Эта переменная содержит имя операционной системы (
  <code>
   'win32'
  </code>
  ,
  <code>
   'darwin'
  </code>
  ,
  <code>
   'linux'
  </code>
  ).
 </li>
 <li>
  <code>
   os.system(...)
  </code>
  : Эта функция передает текстовую команду на выполнение командной оболочке ОС.
 </li>
 <li>
  <code>
   #
  </code>
  : Символ решетки начинает
  <strong>
   комментарий
  </strong>
  . Весь текст после него в строке игнорируется интерпретатором и служит только для пояснений разработчику.
 </li>
</ul>
<p>
 Этот пример демонстрирует, как программа на Python может выполнять осмысленные действия, взаимодействуя с окружением, в котором она запущена.
</p>
<h2 id="112-редакторы-кода-и-среды-разработки-ide">
 1.12. Редакторы кода и среды разработки (IDE)
</h2>
<p>
 Писать код в простом Блокноте неудобно. Для этого существуют специализированные инструменты: редакторы кода и IDE.
</p>
<h3 id="1121-редактор-ide-и-idle-в-чем-разница">
 1.12.1. Редактор, IDE и IDLE: в чем разница?
</h3>
<ul>
 <li>
  <strong>
   Текстовый редактор кода (Code Editor):
  </strong>
  Легковесная программа для написания кода. Основные функции: подсветка синтаксиса (разные части кода окрашиваются в разные цвета) и автодополнение. Пример: VS Code (изначально), Sublime Text.
 </li>
 <li>
  <strong>
   IDE (Integrated Development Environment / Интегрированная среда разработки):
  </strong>
  Мощный "комбайн" для разработчика. Включает в себя редактор кода, а также множество дополнительных инструментов: средства для отладки, интеграцию с системами контроля версий (Git), инструменты для управления проектом и многое другое. Пример: PyCharm, Visual Studio.
 </li>
 <li>
  <strong>
   IDLE (Integrated Development and Learning Environment):
  </strong>
  Простая IDE, которая поставляется вместе с Python. Она отлично подходит для самых первых шагов и обучения, но для реальных проектов ее возможностей недостаточно.
 </li>
</ul>
<blockquote>
 <p>
  <strong>
   Отладка (Debugging)
  </strong>
  — это процесс поиска и исправления ошибок (багов) в программном коде. IDE предоставляют специальные инструменты (отладчики), которые позволяют выполнять программу пошагово и отслеживать значения переменных.
 </p>
</blockquote>
<h3 id="1122-знакомство-с-idle-встроенная-среда-обучения">
 1.12.2. Знакомство с IDLE: встроенная среда обучения
</h3>
<p>
 Давайте кратко познакомимся с IDLE, так как это самый быстрый способ начать писать код.
</p>
<ol>
 <li>
  <strong>
   Запуск:
  </strong>
  Найдите в меню "Пуск" (Windows) или в папке "Программы" (macOS) вашу версию Python и запустите
  <code>
   IDLE
  </code>
  .
 </li>
 <li>
  <strong>
   Настройка:
  </strong>
  <ul>
   <li>
    Откроется окно
    <code>
     Python Shell
    </code>
    (интерактивный режим). Перейдите в
    <code>
     Options -&gt; Configure IDLE
    </code>
    .
   </li>
   <li>
    Во вкладке
    <code>
     Highlights
    </code>
    выберите темную тему (
    <code>
     IDLE Dark
    </code>
    ), чтобы снизить нагрузку на глаза.
   </li>
   <li>
    Во вкладке
    <code>
     Fonts/Tabs
    </code>
    увеличьте размер шрифта до комфортного (например, 16).
   </li>
  </ul>
 </li>
 <li>
  <strong>
   Работа с файлами:
  </strong>
  <ul>
   <li>
    Чтобы создать новый файл, нажмите
    <code>
     File -&gt; New File
    </code>
    . Откроется пустое окно редактора.
   </li>
   <li>
    Чтобы открыть существующий файл, нажмите
    <code>
     File -&gt; Open
    </code>
    .
   </li>
   <li>
    Напишите ваш код (например,
    <code>
     print("Hello, IDLE!")
    </code>
    ).
   </li>
   <li>
    Сохраните файл (
    <code>
     File -&gt; Save
    </code>
    или
    <code>
     Ctrl+S
    </code>
    ), дав ему имя с расширением
    <code>
     .py
    </code>
    .
   </li>
   <li>
    Для запуска скрипта нажмите
    <code>
     Run -&gt; Run Module
    </code>
    (или клавишу
    <code>
     F5
    </code>
    ). Результат выполнения появится в окне
    <code>
     Python Shell
    </code>
    .
   </li>
  </ul>
 </li>
</ol>
<h3 id="1123-профессиональные-инструменты-vs-code-и-pycharm">
 1.12.3. Профессиональные инструменты: VS Code и PyCharm
</h3>
<p>
 Для серьезной разработки используются более мощные инструменты. Самые популярные для Python — это
 <strong>
  Visual Studio Code
 </strong>
 и
 <strong>
  PyCharm
 </strong>
 .
</p>
<ul>
 <li>
  <strong>
   Visual Studio Code (VS Code):
  </strong>
  Бесплатный, легкий, быстрый и невероятно гибкий редактор от Microsoft. Благодаря огромному количеству расширений его можно превратить в полноценную IDE для любого языка программирования. Мы будем использовать его в нашем курсе.
 </li>
 <li>
  <strong>
   PyCharm:
  </strong>
  Специализированная IDE для Python от компании JetBrains. Считается золотым стандартом в Python-разработке. Существует в двух версиях: бесплатной
  <code>
   Community
  </code>
  (с базовым функционалом) и платной
  <code>
   Professional
  </code>
  (с расширенными инструментами для веб-разработки и анализа данных).
 </li>
</ul>
<p>
 Для начинающего разработчика VS Code является идеальным выбором: он менее требователен к ресурсам компьютера, его интерфейс проще, и он полностью бесплатен.
</p>
<h3 id="1124-установка-и-первоначальная-настроика-visual-studio-code">
 1.12.4. Установка и первоначальная настройка Visual Studio Code
</h3>
<ol>
 <li>
  Перейдите на официальный сайт
  <a href="https://code.visualstudio.com">
   code.visualstudio.com
  </a>
  и скачайте установщик для вашей ОС.
 </li>
 <li>
  Запустите установщик.
 </li>
 <li>
  Примите лицензионное соглашение.
 </li>
 <li>
  На шаге "Select Additional Tasks" (Выбор дополнительных задач) обязательно поставьте следующие галочки:
  <ul>
   <li>
    <code>
     Add 'Open with Code' action to Windows Explorer file context menu
    </code>
    (Добавить в контекстное меню файлов).
   </li>
   <li>
    <code>
     Add 'Open with Code' action to Windows Explorer directory context menu
    </code>
    (Добавить в контекстное меню папок).
   </li>
   <li>
    <code>
     Register Code as an editor for supported file types
    </code>
    (Зарегистрировать как редактор).
   </li>
   <li>
    <code>
     Add to PATH
    </code>
    (Добавить в PATH).
   </li>
  </ul>
 </li>
 <li>
  Завершите установку и запустите VS Code.
 </li>
</ol>
<p>
 <strong>
  Обзор интерфейса:
 </strong>
</p>
<p>
 При первом запуске вас встретит приветственное окно. Его можно закрыть и убрать галочку
 <code>
  Show welcome page on startup
 </code>
 .
</p>
<p>
 Основные элементы интерфейса расположены на
 <strong>
  Панели действий (Activity Bar)
 </strong>
 слева:
</p>
<ul>
 <li>
  <strong>
   Explorer (Проводник):
  </strong>
  Здесь отображается структура папок и файлов вашего проекта.
 </li>
 <li>
  <strong>
   Search (Поиск):
  </strong>
  Глобальный поиск по всем файлам проекта.
 </li>
 <li>
  <strong>
   Source Control (Система контроля версий):
  </strong>
  Интеграция с Git для отслеживания изменений в коде.
 </li>
</ul>
<blockquote>
 <p>
  <strong>
   Git
  </strong>
  — это распределенная система контроля версий, стандарт в современной разработке. Она позволяет сохранять историю изменений проекта и совместно работать над кодом.
 </p>
 <ul>
  <li>
   <strong>
    Run and Debug (Запуск и отладка):
   </strong>
   Инструменты для запуска и отладки ваших программ.
  </li>
  <li>
   <strong>
    Extensions (Расширения):
   </strong>
   Магазин расширений, где мы установим поддержку Python.
  </li>
 </ul>
</blockquote>
<p>
 В следующей главе мы настроим VS Code для работы с Python и напишем наши первые полноценные программы.
</p>
<h1 id="глава-1-введение-в-python-и-основы-программирования-продолжение-2">
 Глава 1: Введение в Python и основы программирования (продолжение)
</h1>
<h2 id="113-настроика-рабочеи-среды-visual-studio-code">
 1.13. Настройка рабочей среды: Visual Studio Code
</h2>
<p>
 После установки Python и необходимых инструментов пришло время настроить профессиональную среду для написания кода. Мы будем использовать Visual Studio Code (VS Code) — мощный и гибкий редактор, который благодаря расширениям превращается в полноценную IDE.
</p>
<h3 id="1131-первоначальныи-обзор-и-настроика-интерфеиса">
 1.13.1. Первоначальный обзор и настройка интерфейса
</h3>
<p>
 При первом запуске VS Code вы увидите основной интерфейс. Давайте внесем несколько небольших изменений для удобства.
</p>
<ul>
 <li>
  <strong>
   Отключение Command Center:
  </strong>
  В верхней части окна по центру расположена панель
  <code>
   Command Center
  </code>
  . Это поле для быстрого поиска, но доступ к его функционалу легко получить через комбинацию клавиш
  <code>
   Ctrl+Shift+P
  </code>
  (на macOS
  <code>
   Cmd+Shift+P
  </code>
  ). Чтобы освободить место на экране, кликните по этой панели правой кнопкой мыши и снимите галочку с
  <code>
   Command Center
  </code>
  .
 </li>
</ul>
<blockquote>
 <p>
  <strong>
   Горячие клавиши (Hotkeys/Shortcuts):
  </strong>
  Это комбинации клавиш на клавиатуре, которые выполняют определенные команды в программе. Их использование значительно ускоряет работу по сравнению с навигацией через меню с помощью мыши.
 </p>
</blockquote>
<ul>
 <li>
  <p>
   <strong>
    Верхнее меню (Menu Bar):
   </strong>
  </p>
  <ul>
   <li>
    <strong>
     File (Файл):
    </strong>
    Управление файлами и папками (проектами), доступ к основным настройкам (
    <code>
     Preferences -&gt; Settings
    </code>
    ). На macOS это меню может называться
    <code>
     Code
    </code>
    .
   </li>
   <li>
    <strong>
     Edit (Правка):
    </strong>
    Стандартные операции с текстом: отмена (
    <code>
     Ctrl+Z
    </code>
    ), возврат (
    <code>
     Ctrl+Y
    </code>
    ), вырезать, копировать, вставить. Эти действия почти всегда выполняются горячими клавишами.
   </li>
   <li>
    <strong>
     Selection (Выделение):
    </strong>
    Инструменты для работы с выделенным текстом. Также используются через горячие клавиши.
   </li>
   <li>
    <strong>
     View (Вид):
    </strong>
    Управление отображением панелей, разделение окна редактора на несколько частей для одновременной работы с несколькими файлами.
   </li>
   <li>
    <strong>
     Go (Переход):
    </strong>
    Навигация по коду без использования мыши.
   </li>
   <li>
    <strong>
     Run (Запуск):
    </strong>
    Запуск и отладка вашего кода.
   </li>
   <li>
    <strong>
     Terminal (Терминал):
    </strong>
    Управление встроенным терминалом.
   </li>
  </ul>
 </li>
 <li>
  <p>
   <strong>
    Встроенный терминал:
   </strong>
   Нажмите в верхнем меню
   <code>
    Terminal -&gt; New Terminal
   </code>
   . В нижней части редактора откроется панель терминала. На Windows по умолчанию это будет
   <code>
    PowerShell
   </code>
   , на macOS —
   <code>
    Zsh
   </code>
   , на Linux —
   <code>
    Bash
   </code>
   . Это тот же самый системный терминал, но интегрированный в редактор для удобства. Закрыть его можно, нажав на иконку корзины на панели терминала.
  </p>
 </li>
</ul>
<h3 id="1132-настроика-проекта-и-установка-расширении">
 1.13.2. Настройка проекта и установка расширений
</h3>
<p>
 Правильная работа с проектом начинается с открытия рабочей папки в редакторе.
</p>
<ol>
 <li>
  Создайте на компьютере папку для нашего курса (например,
  <code>
   python_course
  </code>
  ).
 </li>
 <li>
  Скопируйте в нее файл с кодом, который мы рассматривали ранее (скрипт автоматизации
  <code>
   test.py
  </code>
  ).
 </li>
 <li>
  В VS Code перейдите в меню
  <code>
   File -&gt; Open Folder
  </code>
  и выберите созданную вами папку.
 </li>
 <li>
  Редактор запросит подтверждение, доверяете ли вы содержимому этой папки. Нажмите
  <code>
   Yes, I trust the authors
  </code>
  .
 </li>
</ol>
<p>
 Теперь в
 <strong>
  Проводнике (Explorer)
 </strong>
 слева вы видите структуру вашей папки. Если вы откроете встроенный терминал, он автоматически запустится в директории вашего проекта, что очень удобно.
</p>
<p>
 VS Code "из коробки" имеет базовую подсветку синтаксиса, но для полноценной работы с Python необходимо установить специализированное расширение.
</p>
<ol>
 <li>
  Перейдите на панель
  <strong>
   Расширения (Extensions)
  </strong>
  слева (иконка с кубиками).
 </li>
 <li>
  В строке поиска введите
  <code>
   Python
  </code>
  .
 </li>
 <li>
  Найдите расширение от
  <strong>
   Microsoft
  </strong>
  (у него более 100 миллионов скачиваний) и нажмите
  <strong>
   Install
  </strong>
  .
 </li>
 <li>
  Закройте вкладку с расширением после установки.
 </li>
</ol>
<p>
 Теперь VS Code полностью готов к работе с Python. В нижней
 <strong>
  Панели состояния (Status Bar)
 </strong>
 вы увидите версию выбранного интерпретатора Python, кодировку файла и другие полезные сведения.
</p>
<h3 id="1133-ключевые-расширения-для-python">
 1.13.3. Ключевые расширения для Python
</h3>
<p>
 Вместе с основным расширением Python автоматически устанавливаются два важнейших компонента:
</p>
<ul>
 <li>
  <strong>
   Pylance:
  </strong>
  Это "мозг" для работы с Python. Он анализирует ваш код в реальном времени и обеспечивает:
  <ul>
   <li>
    <strong>
     Автодополнение (Autocompletion):
    </strong>
    Предлагает варианты завершения кода по мере набора.
   </li>
   <li>
    <strong>
     Подсказки и документацию:
    </strong>
    При наведении на функцию или переменную показывает информацию о том, что она делает и какие параметры принимает.
   </li>
   <li>
    <strong>
     Анализ кода:
    </strong>
    Подчеркивает потенциальные ошибки еще до запуска программы.
   </li>
  </ul>
 </li>
 <li>
  <strong>
   Python Debugger:
  </strong>
  Инструмент для отладки, который позволяет выполнять код пошагово, отслеживать значения переменных и находить ошибки.
 </li>
</ul>
<p>
 Еще одно расширение, которое необходимо установить вручную, — это
 <strong>
  форматер кода
 </strong>
 .
</p>
<blockquote>
 <p>
  <strong>
   Форматер (Formatter)
  </strong>
  — это инструмент, который автоматически приводит ваш код к единому стилю оформления согласно общепринятым стандартам. Он расставляет отступы, убирает лишние пробелы и пустые строки, делая код чистым и читаемым.
 </p>
</blockquote>
<p>
 Самым популярным и строгим форматером для Python является
 <strong>
  Black
 </strong>
 .
</p>
<ol>
 <li>
  Вернитесь в раздел
  <strong>
   Расширения
  </strong>
  .
 </li>
 <li>
  В поиске введите
  <code>
   Black Formatter
  </code>
  .
 </li>
 <li>
  Установите расширение от
  <strong>
   Microsoft
  </strong>
  .
 </li>
</ol>
<p>
 Чтобы применить форматирование, кликните правой кнопкой мыши по коду и выберите
 <code>
  Format Document With...
 </code>
 -&gt;
 <code>
  Configure Default Formatter...
 </code>
 -&gt;
 <code>
  Black Formatter
 </code>
 . Теперь ваш код будет автоматически отформатирован по стандарту.
</p>
<blockquote>
 <p>
  <strong>
   PEP 8
  </strong>
  — это официальный документ, который описывает соглашения по стилю написания кода на Python. Следование этим правилам делает код удобочитаемым и единообразным, что крайне важно при работе в команде. Форматеры, такие как Black, помогают автоматически соблюдать большинство правил PEP 8.
 </p>
</blockquote>
<h3 id="1134-работа-с-кодом-запуск-и-автосохранение">
 1.13.4. Работа с кодом: запуск и автосохранение
</h3>
<ul>
 <li>
  <strong>
   Создание файла:
  </strong>
  В панели
  <strong>
   Проводник (Explorer)
  </strong>
  нажмите иконку
  <code>
   New File
  </code>
  и назовите его, например,
  <code>
   app.py
  </code>
  . Расширение
  <code>
   .py
  </code>
  обязательно.
 </li>
 <li>
  <strong>
   Запуск скрипта:
  </strong>
  После установки расширения Python в правом верхнем углу редактора появится кнопка в виде треугольника (
  <code>
   Run Python File
  </code>
  ). Нажмите на нее, и ваш код будет выполнен во встроенном терминале.
 </li>
 <li>
  <strong>
   Автосохранение:
  </strong>
  Чтобы не нажимать
  <code>
   Ctrl+S
  </code>
  каждый раз после изменений, включите автосохранение. Перейдите в меню
  <code>
   File
  </code>
  и кликните на
  <code>
   Auto Save
  </code>
  , чтобы появилась галочка.
 </li>
</ul>
<h3 id="1135-глубокая-настроика-через-settingsjson">
 1.13.5. Глубокая настройка через settings.json
</h3>
<p>
 VS Code хранит все свои настройки в текстовом файле
 <code>
  settings.json
 </code>
 . Это позволяет быстро настраивать редактор, просто копируя и вставляя готовые конфигурации.
</p>
<ol>
 <li>
  Нажмите на иконку шестеренки в левом нижнем углу и выберите
  <code>
   Settings
  </code>
  .
 </li>
 <li>
  В правом верхнем углу открывшейся вкладки нажмите на иконку файла (
  <code>
   Open Settings (JSON)
  </code>
  ).
 </li>
 <li>
  Откроется файл
  <code>
   settings.json
  </code>
  .
 </li>
</ol>
<blockquote>
 <p>
  <strong>
   JSON (JavaScript Object Notation)
  </strong>
  — это текстовый формат для хранения и обмена данными. Он использует пары "ключ-значение" (например,
  <code>
   "fontSize": 16
  </code>
  ), что делает его легко читаемым как для человека, так и для машины.
 </p>
</blockquote>
<p>
 Вы можете скопировать готовую конфигурацию, которая улучшит внешний вид и функциональность редактора. Этот файл содержит настройки для шрифтов, темы оформления, поведения терминала и расширений.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="p">{</span>
<span class="w">    </span><span class="c1">// Настройки для комфортной работы и обучения</span>
<span class="w">    </span><span class="nt">"editor.fontSize"</span><span class="p">:</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span>
<span class="w">    </span><span class="nt">"editor.minimap.enabled"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="c1">// Отключаем миникарту кода справа</span>
<span class="w">    </span><span class="nt">"editor.wordWrap"</span><span class="p">:</span><span class="w"> </span><span class="s2">"on"</span><span class="p">,</span><span class="w"> </span><span class="c1">// Включаем перенос строк</span>
<span class="w">    </span><span class="nt">"terminal.integrated.fontSize"</span><span class="p">:</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span>
<span class="w">    </span><span class="nt">"workbench.startupEditor"</span><span class="p">:</span><span class="w"> </span><span class="s2">"none"</span><span class="p">,</span><span class="w"> </span><span class="c1">// Не показывать приветственное окно</span>
<span class="w">    </span><span class="nt">"files.autoSave"</span><span class="p">:</span><span class="w"> </span><span class="s2">"afterDelay"</span><span class="p">,</span><span class="w"> </span><span class="c1">// Автосохранение с небольшой задержкой</span>
<span class="w">    </span><span class="nt">"python.defaultInterpreterPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"python3"</span><span class="p">,</span><span class="w"> </span><span class="c1">// Указать путь, если нужно</span>

<span class="w">    </span><span class="c1">// Настройки форматера</span>
<span class="w">    </span><span class="nt">"editor.defaultFormatter"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ms-python.black-formatter"</span><span class="p">,</span>
<span class="w">    </span><span class="nt">"editor.formatOnSave"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Настройки анализатора кода Pylance</span>
<span class="w">    </span><span class="nt">"python.analysis.typeCheckingMode"</span><span class="p">:</span><span class="w"> </span><span class="s2">"basic"</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Продвинутая тема оформления (пример)</span>
<span class="w">    </span><span class="nt">"workbench.colorTheme"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Default Dark+"</span><span class="p">,</span>
<span class="w">    </span><span class="nt">"editor.tokenColorCustomizations"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">"textMateRules"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="nt">"scope"</span><span class="p">:</span><span class="w"> </span><span class="s2">"keyword.control"</span><span class="p">,</span>
<span class="w">                </span><span class="nt">"settings"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">"foreground"</span><span class="p">:</span><span class="w"> </span><span class="s2">"#C586C0"</span><span class="w"> </span><span class="p">}</span>
<span class="w">            </span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="nt">"scope"</span><span class="p">:</span><span class="w"> </span><span class="s2">"entity.name.function"</span><span class="p">,</span>
<span class="w">                </span><span class="nt">"settings"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">"foreground"</span><span class="p">:</span><span class="w"> </span><span class="s2">"#DCDCAA"</span><span class="w"> </span><span class="p">}</span>
<span class="w">            </span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="nt">"scope"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span>
<span class="w">                </span><span class="nt">"settings"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">"foreground"</span><span class="p">:</span><span class="w"> </span><span class="s2">"#CE9178"</span><span class="w"> </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>
 <em>
  Вставьте этот код в ваш
  <code>
   settings.json
  </code>
  , сохраните (
  <code>
   Ctrl+S
  </code>
  ) и перезапустите VS Code.
 </em>
</p>
<p>
 В этой конфигурации:
</p>
<ul>
 <li>
  Увеличены шрифты для комфортного чтения.
 </li>
 <li>
  Отключена
  <strong>
   миникарта
  </strong>
  (маленький предпросмотр кода справа), чтобы увеличить рабочее пространство.
 </li>
 <li>
  Включено автосохранение и форматирование кода при сохранении.
 </li>
 <li>
  Настроена цветовая схема для лучшей читаемости разных частей синтаксиса.
 </li>
</ul>
<h3 id="1136-дополнительные-расширения-и-рекомендации">
 1.13.6. Дополнительные расширения и рекомендации
</h3>
<p>
 Существует огромное количество расширений, но на начальном этапе стоит проявить осторожность.
</p>
<ul>
 <li>
  <strong>
   Code Spell Checker:
  </strong>
  Проверяет орфографию в коде и комментариях. Может быть полезен, но часто подчеркивает сокращения (например,
  <code>
   btn
  </code>
  вместо
  <code>
   button
  </code>
  ), что может сбивать с толку новичка.
 </li>
 <li>
  <strong>
   Language Packs (Пакеты локализации):
  </strong>
  Позволяют перевести интерфейс VS Code на русский язык.
  <strong>
   Настоятельно рекомендуется не делать этого.
  </strong>
  Привыкание к англоязычному интерфейсу — важная часть становления разработчика, так как вся документация, сообщения об ошибках и профессиональное сообщество используют английский.
 </li>
</ul>
<p>
 Все необходимые горячие клавиши можно найти в меню
 <code>
  Help -&gt; Keyboard Shortcuts Reference
 </code>
 .
</p>
<h2 id="114-альтернативная-среда-знакомство-с-pycharm">
 1.14. Альтернативная среда: знакомство с PyCharm
</h2>
<p>
 Работать на Python и не знать о PyCharm — все равно что не знать о VS Code. PyCharm от компании JetBrains — это специализированная IDE, которая считается "золотым стандартом" в Python-разработке.
</p>
<h3 id="1141-установка-и-первыи-запуск">
 1.14.1. Установка и первый запуск
</h3>
<ol>
 <li>
  Перейдите на официальный сайт
  <a href="https://www.jetbrains.com/pycharm">
   jetbrains.com/pycharm
  </a>
  .
 </li>
 <li>
  Существует две версии:
  <ul>
   <li>
    <strong>
     Professional (платная):
    </strong>
    С расширенными инструментами для веб-разработки и анализа данных.
   </li>
   <li>
    <strong>
     Community (бесплатная):
    </strong>
    Полностью бесплатная версия, которой более чем достаточно для изучения и работы с "чистым" Python.
   </li>
  </ul>
 </li>
 <li>
  Скачайте и установите
  <strong>
   Community Edition
  </strong>
  как обычную программу. После установки перезагрузите компьютер.
 </li>
</ol>
<p>
 При первом запуске PyCharm предложит создать новый проект (
 <code>
  New Project
 </code>
 ) или открыть существующий (
 <code>
  Open
 </code>
 ). Выберем
 <code>
  Open
 </code>
 и укажем путь к нашей папке
 <code>
  python_course
 </code>
 .
</p>
<h3 id="1142-особенности-интерфеиса-и-работы">
 1.14.2. Особенности интерфейса и работы
</h3>
<p>
 Хотя общая концепция похожа на VS Code, есть ключевые отличия:
</p>
<ul>
 <li>
  <strong>
   Окно проекта (Project):
  </strong>
  Слева отображается структура проекта. По умолчанию PyCharm может показывать проект как вложенную сущность. Если вам это неудобно, можно переключиться в режим
  <code>
   Project Files
  </code>
  , который выглядит так же, как в VS Code.
 </li>
 <li>
  <strong>
   Интерактивная консоль Python (Python Console):
  </strong>
  В нижней панели есть специальная вкладка
  <code>
   Python Console
  </code>
  . Это готовый к работе интерактивный режим Python, где можно быстро тестировать код. При работе в нем справа отображаются все созданные переменные и их значения, что очень удобно для обучения.
 </li>
 <li>
  <strong>
   Запуск скрипта:
  </strong>
  Чтобы запустить файл, откройте его и нажмите на зеленую кнопку
  <code>
   Run
  </code>
  вверху справа или кликните правой кнопкой мыши по коду и выберите
  <code>
   Run 'имя_файла'
  </code>
  .
 </li>
</ul>
<h3 id="1143-настроики-и-плагины">
 1.14.3. Настройки и плагины
</h3>
<p>
 Все настройки находятся в меню
 <code>
  File -&gt; Settings
 </code>
 . Расширения здесь называются
 <strong>
  Плагины (Plugins)
 </strong>
 и устанавливаются через соответствующий раздел (
 <code>
  Marketplace
 </code>
 ). Для начала работы в PyCharm уже все настроено по умолчанию. Если вы захотите изменить тему оформления или размер шрифта, это можно сделать в
 <code>
  Settings -&gt; Editor -&gt; Font
 </code>
 и
 <code>
  Settings -&gt; Appearance &amp; Behavior -&gt; Appearance
 </code>
 .
</p>
<h3 id="1144-предупреждения-и-реальные-ошибки">
 1.14.4. Предупреждения и реальные ошибки
</h3>
<p>
 PyCharm проводит очень глубокий анализ кода и часто подсвечивает моменты, которые не являются реальными ошибками, а скорее стилистическими недочетами или опечатками (например, в комментариях на кириллице).
</p>
<p>
 <strong>
  Важно:
 </strong>
 Научитесь отличать
 <strong>
  предупреждения IDE
 </strong>
 от
 <strong>
  ошибок выполнения
 </strong>
 . Если при запуске скрипта в терминале не появилось красного текста с ошибкой, а программа выдала ожидаемый результат, значит, код работает корректно, даже если редактор что-то подсвечивает.
</p>
<h2 id="115-за-кулисами-как-на-самом-деле-работает-ваш-код">
 1.15. За кулисами: как на самом деле работает ваш код
</h2>
<p>
 Мы уже написали программу, которая выводит сообщение в терминал. Но что происходит "под капотом", когда интерпретатор выполняет команду
 <code>
  print("Hello")
 </code>
 ? Понимание этого процесса отделяет новичка от осознанного разработчика.
</p>
<h3 id="1151-уровни-абстракции-в-программировании">
 1.15.1. Уровни абстракции в программировании
</h3>
<blockquote>
 <p>
  <strong>
   Уровень абстракции (Level of Abstraction)
  </strong>
  — это концепция, позволяющая скрыть сложные детали реализации, предоставляя простой интерфейс для работы. Современные языки программирования имеют высокий уровень абстракции, что позволяет разработчику не думать о том, как устроен процессор или память.
 </p>
</blockquote>
<p>
 Когда вы пишете
 <code>
  print()
 </code>
 , вы используете высокий уровень абстракции. Вы не задумываетесь, как именно символы появятся на экране. Вы просто даете команду, а язык программирования и операционная система делают всю "грязную" работу за вас.
</p>
<h3 id="1152-ядро-ос-и-пользовательское-пространство">
 1.15.2. Ядро ОС и пользовательское пространство
</h3>
<p>
 Любая операционная система (Windows, macOS, Linux) состоит из двух основных частей:
</p>
<ol>
 <li>
  <strong>
   Пользовательское пространство (Userspace):
  </strong>
  Здесь находятся все программы, с которыми вы взаимодействуете: браузеры, текстовые редакторы, игры и сам интерпретатор Python. Программы в этом пространстве не имеют прямого доступа к "железу" компьютера.
 </li>
 <li>
  <strong>
   Ядро (Kernel):
  </strong>
  Это центральная, самая низкоуровневая часть ОС. Ядро управляет всеми ресурсами компьютера: процессором, оперативной памятью, жесткими дисками. Оно выступает посредником между программами и аппаратным обеспечением.
 </li>
</ol>
<blockquote>
 <p>
  <strong>
   Ядро (Kernel)
  </strong>
  — это основная часть операционной системы, которая управляет ресурсами компьютера и обеспечивает взаимодействие между программным и аппаратным обеспечением.
 </p>
</blockquote>
<h3 id="1153-системные-вызовы-мост-между-программои-и-ядром">
 1.15.3. Системные вызовы: мост между программой и ядром
</h3>
<p>
 Чтобы программа из пользовательского пространства могла что-то сделать (например, прочитать файл с диска или вывести текст на экран), она должна попросить об этом ядро. Этот запрос называется
 <strong>
  системным вызовом
 </strong>
 .
</p>
<blockquote>
 <p>
  <strong>
   Системный вызов (System Call)
  </strong>
  — это механизм, с помощью которого программа запрашивает у ядра операционной системы выполнение какой-либо операции, например, ввод-вывод данных или управление процессами.
 </p>
</blockquote>
<p>
 Когда ваша Python-программа выполняет команду
 <code>
  print("Hello")
 </code>
 , на самом деле происходит следующее:
</p>
<ol>
 <li>
  Интерпретатор Python видит функцию
  <code>
   print()
  </code>
  .
 </li>
 <li>
  Он обращается к своей
  <strong>
   стандартной библиотеке
  </strong>
  , где реализована эта функция.
 </li>
 <li>
  Код в стандартной библиотеке формирует
  <strong>
   системный вызов
  </strong>
  (в Linux это, например, вызов
  <code>
   write
  </code>
  ).
 </li>
 <li>
  Ядро ОС получает этот вызов и данные ("Hello").
 </li>
 <li>
  Ядро, в свою очередь, через
  <strong>
   драйвер
  </strong>
  видеокарты отдает команду отрисовать эти символы на экране.
 </li>
</ol>
<blockquote>
 <p>
  <strong>
   Драйвер (Driver)
  </strong>
  — это специальная программа, которая позволяет операционной системе взаимодействовать с конкретным аппаратным устройством (например, видеокартой, принтером или сетевой картой).
 </p>
</blockquote>
<h3 id="1154-иерархия-языков-от-python-до-машинного-кода">
 1.15.4. Иерархия языков: от Python до машинного кода
</h3>
<p>
 Этот процесс имеет несколько уровней абстракции, построенных друг на друге:
</p>
<ol>
 <li>
  <strong>
   Python (Высокоуровневый язык):
  </strong>
  Вы пишете
  <code>
   print("Hello")
  </code>
  . Просто и понятно.
 </li>
 <li>
  <strong>
   Язык C (Низкоуровневый язык):
  </strong>
  Сам интерпретатор Python написан в основном на языке C. Стандартная библиотека Python обращается к функциям языка C, которые реализуют системные вызовы.
 </li>
 <li>
  <strong>
   Ассемблер (Язык самого низкого уровня):
  </strong>
  Функции языка C, в свою очередь, преобразуются в команды на языке ассемблера — текстовом представлении инструкций для процессора.
 </li>
 <li>
  <strong>
   Машинный код (Код для процессора):
  </strong>
  Команды ассемблера переводятся в машинный код — последовательность нулей и единиц, которую непосредственно понимает и выполняет процессор.
 </li>
</ol>
<blockquote>
 <p>
  <strong>
   Машинный код (Machine Code)
  </strong>
  — это набор инструкций, представленный в двоичном виде (нули и единицы), который может быть выполнен непосредственно центральным процессором компьютера.
 </p>
</blockquote>
<h3 id="1155-итоги-зачем-нужны-абстракции">
 1.15.5. Итоги: зачем нужны абстракции?
</h3>
<p>
 Высокие уровни абстракции в языках вроде Python дают огромные преимущества:
</p>
<ul>
 <li>
  <strong>
   Скорость разработки:
  </strong>
  Не нужно думать об управлении памятью и системных вызовах.
 </li>
 <li>
  <strong>
   Безопасность:
  </strong>
  Автоматическое управление памятью предотвращает целый класс распространенных ошибок и уязвимостей.
 </li>
 <li>
  <strong>
   Переносимость:
  </strong>
  Код на Python работает на разных операционных системах, потому что интерпретатор сам "договаривается" с каждым ядром через нужные системные вызовы.
 </li>
</ul>
<h2 id="116-основы-основ-переменные-и-данные">
 1.16. Основы основ: переменные и данные
</h2>
<p>
 Главная задача любой программы — управлять данными. Чтобы это делать, данные нужно где-то хранить и иметь к ним доступ. Для этого существуют переменные.
</p>
<h3 id="1161-что-такое-переменная">
 1.16.1. Что такое переменная?
</h3>
<p>
 Когда вы пишете в коде
 <code>
  1000
 </code>
 или
 <code>
  "Hello"
 </code>
 , интерпретатор создает в оперативной памяти
 <strong>
  объект
 </strong>
 , содержащий эти данные. Чтобы иметь возможность повторно использовать эти данные, мы даем им имя.
</p>
<blockquote>
 <p>
  <strong>
   Переменная (Variable)
  </strong>
  — это именованная ссылка на объект, хранящийся в оперативной памяти. Используя имя переменной, мы можем получать, изменять или использовать данные, на которые она ссылается.
 </p>
</blockquote>
<h3 id="1162-создание-и-использование-переменных">
 1.16.2. Создание и использование переменных
</h3>
<p>
 Переменная создается с помощью
 <strong>
  оператора присвоения
 </strong>
 <code>
  =
 </code>
 (знак равно).
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Создаем объект целого числа 1000 в памяти</span>
<span class="c1"># и даем ему имя (переменную) 'num'</span>
<span class="n">num</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="c1"># Теперь мы можем использовать имя 'num' для доступа к данным</span>
<span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</code></pre>
</div>
<p>
 В этом примере мы создали объект
 <code>
  1000
 </code>
 только один раз, а затем дважды обратились к нему по имени
 <code>
  num
 </code>
 .
</p>
<blockquote>
 <p>
  <strong>
   Оператор присвоения (Assignment Operator)
  </strong>
  — это символ (
  <code>
   =
  </code>
  ), который используется для того, чтобы связать имя переменной (слева от оператора) со значением или объектом в памяти (справа от оператора). Это не математическое равенство, а команда "присвоить".
 </p>
</blockquote>
<h3 id="1163-правила-именования-переменных-snake-case">
 1.16.3. Правила именования переменных (Snake Case)
</h3>
<p>
 Чтобы код был читаемым, существуют правила именования переменных:
</p>
<ul>
 <li>
  Имя должно начинаться с буквы или символа подчеркивания (
  <code>
   _
  </code>
  ). Оно не может начинаться с цифры.
 </li>
 <li>
  Имя может содержать буквы, цифры и символ подчеркивания.
 </li>
 <li>
  Имена чувствительны к регистру:
  <code>
   num
  </code>
  ,
  <code>
   Num
  </code>
  и
  <code>
   NUM
  </code>
  — это три разные переменные.
 </li>
 <li>
  Для имен, состоящих из нескольких слов, в Python принято использовать стиль
  <strong>
   Snake Case
  </strong>
  : слова разделяются символом подчеркивания (
  <code>
   my_first_number
  </code>
  ).
 </li>
</ul>
<blockquote>
 <p>
  <strong>
   Snake Case
  </strong>
  — это стиль именования, при котором все слова пишутся в нижнем регистре и разделяются символом подчеркивания. В Python он является стандартом для имен переменных и функций. В других языках часто используется
  <strong>
   Camel Case
  </strong>
  (
  <code>
   myFirstNumber
  </code>
  ).
 </p>
</blockquote>
<ul>
 <li>
  <strong>
   Имя должно отражать суть данных.
  </strong>
  Если переменная хранит имя пользователя, назовите ее
  <code>
   user_name
  </code>
  , а не
  <code>
   x
  </code>
  или
  <code>
   data
  </code>
  .
 </li>
</ul>
<h3 id="1164-зарезервированные-слова-и-встроенные-имена">
 1.16.4. Зарезервированные слова и встроенные имена
</h3>
<p>
 Некоторые слова в Python имеют специальное значение.
</p>
<ul>
 <li>
  <strong>
   Ключевые (зарезервированные) слова:
  </strong>
  Это команды языка, такие как
  <code>
   if
  </code>
  ,
  <code>
   else
  </code>
  ,
  <code>
   for
  </code>
  ,
  <code>
   while
  </code>
  ,
  <code>
   def
  </code>
  . Их нельзя использовать в качестве имен переменных. Среда разработки подсветит их особым цветом.
 </li>
 <li>
  <strong>
   Имена встроенных функций:
  </strong>
  Это имена функций, которые доступны всегда, например
  <code>
   print
  </code>
  ,
  <code>
   int
  </code>
  ,
  <code>
   str
  </code>
  . Технически, вы можете создать переменную с таким именем (
  <code>
   print = 10
  </code>
  ), но это "перекроет" оригинальную функцию, и вы больше не сможете ее использовать.
  <strong>
   Никогда так не делайте.
  </strong>
 </li>
</ul>
<h3 id="1165-первая-ошибка-nameerror">
 1.16.5. Первая ошибка: NameError
</h3>
<p>
 Если вы попытаетесь использовать переменную, которая еще не была создана, вы получите ошибку.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="n">my_variable</span><span class="p">)</span> <span class="c1"># Попытка использовать несуществующую переменную</span>
</code></pre>
</div>
<p>
 При запуске этого кода вы увидите в терминале сообщение об ошибке:
</p>
<pre><code>Traceback (most recent call last):
  File "C:\Users\User\python_course\app.py", line 1, in &lt;module&gt;
    print(my_variable)
NameError: name 'my_variable' is not defined
</code></pre>
<ul>
 <li>
  <strong>
   Traceback:
  </strong>
  Показывает путь, по которому выполнение кода привело к ошибке, включая имя файла и номер строки (
  <code>
   line 1
  </code>
  ).
 </li>
 <li>
  <strong>
   NameError:
  </strong>
  Тип ошибки, который означает, что было использовано несуществующее имя.
 </li>
 <li>
  <strong>
   Сообщение:
  </strong>
  <code>
   name 'my_variable' is not defined
  </code>
  — прямое указание на то, что переменная не определена.
 </li>
</ul>
<p>
 Современные редакторы кода, такие как VS Code с расширением Pylance, предупредят вас о такой ошибке еще до запуска, подчеркнув несуществующую переменную.
</p>
<h3 id="1166-манипулирование-данными-и-переприсваивание">
 1.16.6. Манипулирование данными и переприсваивание
</h3>
<p>
 Значение, на которое ссылается переменная, можно изменять (
 <strong>
  переприсваивать
 </strong>
 ).
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">num</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="c1"># Выведет 1000</span>

<span class="n">num</span> <span class="o">=</span> <span class="mi">50</span> <span class="c1"># Теперь переменная 'num' ссылается на новый объект</span>
<span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="c1"># Выведет 50</span>
</code></pre>
</div>
<p>
 С переменными можно выполнять операции. При этом сначала вычисляется выражение справа от
 <code>
  =
 </code>
 , и только потом результат присваивается переменной слева.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">num_one</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">num_two</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># Сначала вычисляется 10 + 5, создается новый объект 15,</span>
<span class="c1"># а затем переменная result начинает на него ссылаться.</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">num_one</span> <span class="o">+</span> <span class="n">num_two</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1"># Выведет 15</span>

<span class="c1"># Можно переприсвоить значение на основе старого</span>
<span class="n">num_one</span> <span class="o">=</span> <span class="n">num_one</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># 10 + 1 -&gt; 11. Теперь num_one ссылается на 11.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">num_one</span><span class="p">)</span> <span class="c1"># Выведет 11</span>
</code></pre>
</div>
<p>
 Для удобного переименования переменной во всем файле выделите ее имя, нажмите
 <code>
  F2
 </code>
 , введите новое имя и нажмите
 <code>
  Enter
 </code>
 . Редактор автоматически заменит все вхождения.
</p>
<h3 id="1167-функция-print-как-инструмент-отладки">
 1.16.7. Функция print() как инструмент отладки
</h3>
<p>
 Функция
 <code>
  print()
 </code>
 — ваш лучший друг на начальном этапе для понимания того, что происходит в коде. В любой момент вы можете "заглянуть" внутрь переменной, просто выведя ее значение на экран.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Сложные вычисления</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Значение c после вычислений:"</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="c1"># Проверяем промежуточный результат</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">c</span> <span class="o">/</span> <span class="mi">3</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Финальное значение d:"</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</code></pre>
</div>
<p>
 В
 <code>
  print()
 </code>
 можно передавать несколько значений через запятую, чтобы выводить осмысленные сообщения, что значительно упрощает отладку. Мы еще вернемся к расширенным возможностям этой функции.
</p>
<h1 id="глава-1-введение-в-python-и-основы-программирования-продолжение-3">
 Глава 1: Введение в Python и основы программирования (продолжение)
</h1>
<h2 id="117-расширенные-возможности-функции-print">
 1.17. Расширенные возможности функции print()
</h2>
<p>
 Мы уже активно используем
 <code>
  print()
 </code>
 для вывода результатов, но эта встроенная функция обладает дополнительными параметрами, которые позволяют гибко настраивать вывод.
</p>
<p>
 Некоторые функции, такие как
 <code>
  print()
 </code>
 , являются
 <strong>
  встроенными
 </strong>
 и доступны в любом месте программы без необходимости импортировать дополнительные модули.
</p>
<p>
 При наведении на
 <code>
  print()
 </code>
 в VS Code вы увидите ее сигнатуру, которая может выглядеть примерно так:
 <code>
  print(*values, sep=' ', end='\n', ...)
 </code>
 . Давайте разберем самые важные параметры.
</p>
<ul>
 <li>
  <p>
   <strong>
    <code>
     *values
    </code>
   </strong>
   : Звездочка означает, что функция может принимать неограниченное количество аргументов. Вы можете передать в
   <code>
    print()
   </code>
   несколько переменных или значений через запятую, и все они будут выведены.
  </p>
  <div class="codehilite">
   <pre><span></span><code><span class="n">result</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">num_one</span> <span class="o">=</span> <span class="mi">11</span>

<span class="c1"># Выводим значения двух переменных одновременно</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">num_one</span><span class="p">)</span>
</code></pre>
  </div>
  <p>
   При запуске вы увидите
   <code>
    15 11
   </code>
   . Обратите внимание, что если забыть запятую, Python воспримет это как синтаксическую ошибку (
   <code>
    SyntaxError
   </code>
   ), и среда разработки даже может подсказать:
   <code>
    Perhaps you forgot a comma?
   </code>
   (Возможно, вы забыли запятую?).
  </p>
 </li>
 <li>
  <p>
   <strong>
    <code>
     sep
    </code>
    (separator — разделитель)
   </strong>
   : Этот параметр определяет, какая строка будет использоваться в качестве разделителя между значениями, которые вы передаете в
   <code>
    print()
   </code>
   . По умолчанию это один пробел (
   <code>
    ' '
   </code>
   ).
  </p>
  <blockquote>
   <p>
    <strong>
     Параметр функции (Function Parameter)
    </strong>
    — это переменная, указанная в определении функции, которая принимает значение при вызове этой функции. Именованные параметры, как
    <code>
     sep
    </code>
    , можно задавать явно по их имени.
   </p>
  </blockquote>
  <p>
   Чтобы изменить разделитель, нужно после всех выводимых значений указать
   <code>
    sep=
   </code>
   и передать новую строку-разделитель.
  </p>
  <div class="codehilite">
   <pre><span></span><code><span class="n">result</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">num_one</span> <span class="o">=</span> <span class="mi">11</span>

<span class="c1"># Используем в качестве разделителя дефис с пробелами</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">num_one</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">" - "</span><span class="p">)</span> <span class="c1"># Выведет: 15 - 11</span>
</code></pre>
  </div>
 </li>
 <li>
  <p>
   <strong>
    <code>
     end
    </code>
    (окончание)
   </strong>
   : Этот параметр контролирует, какой символ или строка будет добавлена в самом конце вывода функции
   <code>
    print()
   </code>
   . По умолчанию это
   <code>
    '\n'
   </code>
   .
  </p>
  <blockquote>
   <p>
    <strong>
     Специальный символ (Special Character)
    </strong>
    — это последовательность символов, которая имеет особое значение. Например,
    <code>
     \n
    </code>
    — это символ переноса строки, который заставляет следующий вывод появляться на новой строке.
   </p>
  </blockquote>
  <p>
   Из-за того что
   <code>
    end
   </code>
   по умолчанию равен
   <code>
    \n
   </code>
   , каждый новый вызов
   <code>
    print()
   </code>
   начинается с новой строки. Мы можем изменить это поведение.
  </p>
  <div class="codehilite">
   <pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="s2">"Первая часть"</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">""</span><span class="p">)</span> <span class="c1"># Убираем перенос строки</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Вторая часть"</span><span class="p">)</span> <span class="c1"># Эта часть напечатается на той же строке</span>

<span class="c1"># Вывод: Первая частьВторая часть</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Первая часть"</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">" | "</span><span class="p">)</span> <span class="c1"># Используем другой разделитель</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Вторая часть"</span><span class="p">)</span>

<span class="c1"># Вывод: Первая часть | Вторая часть</span>
</code></pre>
  </div>
 </li>
</ul>
<p>
 Комбинируя эти параметры, можно очень гибко форматировать консольный вывод для отладки и представления данных.
</p>
<h2 id="118-комментарии-в-коде">
 1.18. Комментарии в коде
</h2>
<p>
 По мере усложнения программ становится важно оставлять пометки и пояснения прямо в коде. Для этого используются комментарии.
</p>
<blockquote>
 <p>
  <strong>
   Комментарий (Comment)
  </strong>
  — это текстовая заметка в исходном коде программы, которая полностью игнорируется интерпретатором или компилятором. Комментарии предназначены для программистов, чтобы пояснить логику работы кода.
 </p>
</blockquote>
<p>
 В Python однострочный комментарий начинается с символа решетки (
 <code>
  #
 </code>
 ). Все, что следует за этим символом до конца строки, не будет выполнено.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Это комментарий. Он объясняет, что происходит ниже.</span>
<span class="c1"># Создаем переменную для хранения суммы</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">num_one</span> <span class="o">+</span> <span class="n">num_two</span> <span class="c1"># Это тоже комментарий, в одной строке с кодом</span>
</code></pre>
</div>
<p>
 <strong>
  Горячие клавиши для комментирования:
 </strong>
 В большинстве редакторов, включая VS Code, можно быстро закомментировать или раскомментировать строку (или несколько выделенных строк) с помощью комбинации клавиш
 <code>
  Ctrl + /
 </code>
 (на английской раскладке клавиатуры).
</p>
<p>
 <strong>
  Зачем нужны комментарии?
 </strong>
</p>
<ol>
 <li>
  <strong>
   Для обучения:
  </strong>
  Чтобы делать пометки для себя и лучше понимать, что делает каждая строка.
 </li>
 <li>
  <strong>
   Для документирования:
  </strong>
  В реальных проектах комментарии объясняют другим разработчикам (и себе в будущем)
  <em>
   почему
  </em>
  код написан именно так, а не
  <em>
   что
  </em>
  он делает.
 </li>
 <li>
  <strong>
   Для временного отключения кода:
  </strong>
  Можно "закомментировать" часть кода, чтобы временно исключить ее из выполнения при тестировании, не удаляя сам код.
 </li>
</ol>
<p>
 <strong>
  Стиль написания комментариев (PEP 8):
 </strong>
</p>
<ul>
 <li>
  Комментарий, описывающий следующую за ним строку, пишется на отдельной строке над ней.
 </li>
 <li>
  Комментарий в одной строке с кодом (inline comment) отделяется от кода
  <strong>
   двумя пробелами
  </strong>
  , затем ставится
  <code>
   #
  </code>
  , еще
  <strong>
   один пробел
  </strong>
  и сам текст комментария.
 </li>
</ul>
<div class="codehilite">
 <pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Правильно оформленный inline-комментарий</span>
</code></pre>
</div>
<h2 id="119-базовые-типы-данных-в-python">
 1.19. Базовые типы данных в Python
</h2>
<p>
 Любая программа работает с данными. Эти данные могут быть числами, текстом, логическими значениями и т.д. В Python у каждого объекта данных есть
 <strong>
  тип
 </strong>
 , который определяет, что это за данные и какие операции с ними можно производить.
</p>
<h3 id="1191-как-данные-хранятся-в-памяти-объекты-и-типы">
 1.19.1. Как данные хранятся в памяти: объекты и типы
</h3>
<p>
 Когда мы пишем в коде
 <code>
  5
 </code>
 или
 <code>
  "hello"
 </code>
 , Python создает в памяти
 <strong>
  объект
 </strong>
 . Этот объект содержит не только само значение (5), но и дополнительную служебную информацию.
</p>
<blockquote>
 <p>
  <strong>
   Объект (Object)
  </strong>
  — это фундаментальное понятие в Python. Это сущность в памяти, которая имеет значение (данные), тип и уникальный идентификатор. Почти все в Python является объектом, включая числа, строки и функции.
 </p>
</blockquote>
<blockquote>
 <p>
  <strong>
   Метаинформация (Metadata)
  </strong>
  — это "данные о данных". В контексте объектов Python это служебная информация, хранящаяся вместе со значением, которая описывает тип объекта, количество ссылок на него и т. д.
 </p>
</blockquote>
<p>
 Благодаря тому, что тип хранится вместе с данными в объекте, Python является языком с
 <strong>
  динамической типизацией
 </strong>
 . Вам не нужно явно указывать тип переменной, как в некоторых других языках (например, C++ или Java). Интерпретатор сам определяет тип по виду данных.
</p>
<h3 id="1192-классификация-типов-данных">
 1.19.2. Классификация типов данных
</h3>
<p>
 Типы данных в Python можно классифицировать по двум признакам:
</p>
<ol>
 <li>
  <strong>
   Простые и составные (контейнерные):
  </strong>
  <ul>
   <li>
    <strong>
     Простые:
    </strong>
    Хранят одно-единственное значение (число, строка).
   </li>
   <li>
    <strong>
     Составные:
    </strong>
    Могут хранить набор других объектов (список, словарь).
   </li>
  </ul>
 </li>
 <li>
  <strong>
   Изменяемые и неизменяемые:
  </strong>
  <ul>
   <li>
    <strong>
     Неизменяемые (Immutable):
    </strong>
    После создания объекта его значение изменить нельзя. Можно лишь создать новый объект на основе старого.
   </li>
   <li>
    <strong>
     Изменяемые (Mutable):
    </strong>
    Значение объекта можно изменить после его создания.
   </li>
  </ul>
 </li>
</ol>
<blockquote>
 <p>
  <strong>
   Неизменяемый тип (Immutable Type)
  </strong>
  — это тип данных, объекты которого не могут быть изменены после их создания. Примеры: числа, строки, кортежи. Любая операция, которая "изменяет" такой объект, на самом деле создает новый.
 </p>
 <p>
  <strong>
   Изменяемый тип (Mutable Type)
  </strong>
  — это тип данных, объекты которого могут быть изменены после их создания. Примеры: списки, словари, множества.
 </p>
</blockquote>
<p>
 Начнем мы с простых неизменяемых типов.
</p>
<h3 id="1193-простые-неизменяемые-типы-данных">
 1.19.3. Простые (неизменяемые) типы данных
</h3>
<table>
 <thead>
  <tr>
   <th style="text-align:left;">
    Тип
   </th>
   <th style="text-align:left;">
    Название в Python
   </th>
   <th style="text-align:left;">
    Описание
   </th>
   <th style="text-align:left;">
    Пример
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td style="text-align:left;">
    <strong>
     Строка
    </strong>
   </td>
   <td style="text-align:left;">
    <code>
     str
    </code>
    (string)
   </td>
   <td style="text-align:left;">
    Последовательность символов, текст.
   </td>
   <td style="text-align:left;">
    <code>
     "hello"
    </code>
    ,
    <code>
     'Python'
    </code>
   </td>
  </tr>
  <tr>
   <td style="text-align:left;">
    <strong>
     Целое число
    </strong>
   </td>
   <td style="text-align:left;">
    <code>
     int
    </code>
    (integer)
   </td>
   <td style="text-align:left;">
    Целые числа без дробной части.
   </td>
   <td style="text-align:left;">
    <code>
     10
    </code>
    ,
    <code>
     -5
    </code>
    ,
    <code>
     1000
    </code>
   </td>
  </tr>
  <tr>
   <td style="text-align:left;">
    <strong>
     Число с плавающей точкой
    </strong>
   </td>
   <td style="text-align:left;">
    <code>
     float
    </code>
   </td>
   <td style="text-align:left;">
    Дробные (вещественные) числа.
   </td>
   <td style="text-align:left;">
    <code>
     3.14
    </code>
    ,
    <code>
     -0.5
    </code>
    ,
    <code>
     2.0
    </code>
   </td>
  </tr>
  <tr>
   <td style="text-align:left;">
    <strong>
     Булево значение
    </strong>
   </td>
   <td style="text-align:left;">
    <code>
     bool
    </code>
    (boolean)
   </td>
   <td style="text-align:left;">
    Логический тип:
    <code>
     True
    </code>
    (истина) или
    <code>
     False
    </code>
    (ложь).
   </td>
   <td style="text-align:left;">
    <code>
     True
    </code>
    ,
    <code>
     False
    </code>
   </td>
  </tr>
  <tr>
   <td style="text-align:left;">
    <strong>
     Отсутствие значения
    </strong>
   </td>
   <td style="text-align:left;">
    <code>
     NoneType
    </code>
   </td>
   <td style="text-align:left;">
    Специальный тип, имеющий одно значение
    <code>
     None
    </code>
    .
   </td>
   <td style="text-align:left;">
    <code>
     None
    </code>
   </td>
  </tr>
 </tbody>
</table>
<h4 id="строки-str">
 Строки (
 <code>
  str
 </code>
 )
</h4>
<p>
 Строки — это текст, заключенный в одинарные (
 <code>
  '
 </code>
 ) или двойные (
 <code>
  "
 </code>
 ) кавычки. В Python даже один символ — это строка.
</p>
<h4 id="целые-числа-int">
 Целые числа (
 <code>
  int
 </code>
 )
</h4>
<p>
 Особенность Python в том, что целые числа (
 <code>
  int
 </code>
 ) имеют
 <strong>
  неограниченную точность
 </strong>
 . Их размер ограничен только объемом доступной оперативной памяти. Вы можете работать с гигантскими числами без каких-либо проблем.
</p>
<h4 id="числа-с-плавающеи-точкои-float">
 Числа с плавающей точкой (
 <code>
  float
 </code>
 )
</h4>
<p>
 Это дробные числа. Разделителем целой и дробной части всегда является
 <strong>
  точка
 </strong>
 . Даже если число целое, но записано с точкой (например,
 <code>
  12.0
 </code>
 ), его тип будет
 <code>
  float
 </code>
 .
</p>
<p>
 <strong>
  Совместимость
  <code>
   int
  </code>
  и
  <code>
   float
  </code>
  :
 </strong>
 Эти два типа совместимы. При выполнении операции с
 <code>
  int
 </code>
 и
 <code>
  float
 </code>
 результат всегда будет иметь тип
 <code>
  float
 </code>
 . Деление (
 <code>
  /
 </code>
 ) двух целых чисел также всегда возвращает
 <code>
  float
 </code>
 .
</p>
<div class="codehilite">
 <pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="mf">2.5</span><span class="p">)</span> <span class="c1"># Выведет 6.5 (float)</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">10</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Выведет 5.0 (float), а не 5 (int)</span>
</code></pre>
</div>
<p>
 <strong>
  Проблема точности
  <code>
   float
  </code>
  :
 </strong>
 Компьютеры хранят числа в двоичной системе, и некоторые дробные числа (например, 0.1 или 0.2) не могут быть представлены в ней с абсолютной точностью. Это приводит к небольшим ошибкам округления.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="c1"># Вывод: 0.30000000000000004</span>
</code></pre>
</div>
<p>
 Это нормальное поведение для чисел с плавающей точкой во всех языках программирования. Для большинства задач этой точности достаточно, но для финансовых или научных расчетов, где точность критична, используют специальные модули.
</p>
<h4 id="ошибки-типов-typeerror-и-специальные-операции">
 Ошибки типов (
 <code>
  TypeError
 </code>
 ) и специальные операции
</h4>
<p>
 Python — язык с
 <strong>
  сильной типизацией
 </strong>
 . Это значит, что он не позволяет смешивать несовместимые типы в операциях.
</p>
<blockquote>
 <p>
  <strong>
   Сильная типизация (Strong Typing)
  </strong>
  — это свойство языка программирования, которое не допускает неявного смешения разных типов данных в операциях. Попытка сложить строку и число вызовет ошибку.
 </p>
 <p>
  <strong>
   Слабая типизация (Weak Typing)
  </strong>
  — свойство языка (например, JavaScript), которое позволяет автоматически преобразовывать типы в операциях. Например, сложение строки "5" и числа 1 может дать строку "51".
 </p>
</blockquote>
<div class="codehilite">
 <pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="s2">"hello"</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="c1"># Вызовет ошибку</span>
</code></pre>
</div>
<p>
 Текст ошибки будет гласить:
 <code>
  TypeError: can only concatenate str (not "int") to str
 </code>
 .
</p>
<blockquote>
 <p>
  <strong>
   Конкатенация (Concatenation)
  </strong>
  — это операция "склеивания" строк. В Python для этого используется оператор
  <code>
   +
  </code>
  .
 </p>
</blockquote>
<p>
 Однако есть исключение из правил: строку можно
 <strong>
  умножить
 </strong>
 на целое число. Это приведет к ее повторению.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="s2">"hello "</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1"># Вывод: hello hello hello</span>
</code></pre>
</div>
<h4 id="булевы-значения-bool">
 Булевы значения (
 <code>
  bool
 </code>
 )
</h4>
<p>
 Тип
 <code>
  bool
 </code>
 имеет всего два значения:
 <code>
  True
 </code>
 (истина) и
 <code>
  False
 </code>
 (ложь). Они используются для проверки условий и управления логикой программы.
</p>
<h4 id="none">
 <code>
  None
 </code>
</h4>
<p>
 <code>
  None
 </code>
 — это специальное значение, которое обозначает "ничего" или "отсутствие значения". Часто используется как заглушка или для обозначения того, что переменная пока не имеет осмысленного значения.
</p>
<h3 id="1194-составные-контеинерные-типы-данных">
 1.19.4. Составные (контейнерные) типы данных
</h3>
<p>
 Это типы, которые могут хранить коллекции других объектов. Мы познакомимся с ними подробно позже, а пока краткий обзор:
</p>
<ul>
 <li>
  <strong>
   <code>
    tuple
   </code>
   (кортеж):
  </strong>
  Неизменяемая упорядоченная коллекция.
 </li>
 <li>
  <strong>
   <code>
    list
   </code>
   (список):
  </strong>
  Изменяемая упорядоченная коллекция.
 </li>
 <li>
  <strong>
   <code>
    dict
   </code>
   (словарь):
  </strong>
  Изменяемая коллекция пар "ключ-значение".
 </li>
 <li>
  <strong>
   <code>
    set
   </code>
   (множество):
  </strong>
  Изменяемая неупорядоченная коллекция уникальных элементов.
 </li>
</ul>
<h2 id="120-динамическая-типизация-и-управление-переменными">
 1.20. Динамическая типизация и управление переменными
</h2>
<p>
 Важной особенностью Python является то, что переменная — это просто имя, ссылка на объект в памяти. Сама переменная типа не имеет, тип есть у объекта, на который она ссылается.
</p>
<h3 id="1201-переприсваивание-и-смена-типа">
 1.20.1. Переприсваивание и смена типа
</h3>
<p>
 Это означает, что одна и та же переменная в разные моменты времени может ссылаться на объекты совершенно разных типов.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">my_var</span> <span class="o">=</span> <span class="mi">100</span>        <span class="c1"># my_var ссылается на объект int</span>
<span class="nb">print</span><span class="p">(</span><span class="n">my_var</span><span class="p">)</span>

<span class="n">my_var</span> <span class="o">=</span> <span class="s2">"some text"</span> <span class="c1"># Теперь my_var ссылается на объект str</span>
<span class="nb">print</span><span class="p">(</span><span class="n">my_var</span><span class="p">)</span>

<span class="n">my_var</span> <span class="o">=</span> <span class="kc">True</span>       <span class="c1"># А теперь на объект bool</span>
<span class="nb">print</span><span class="p">(</span><span class="n">my_var</span><span class="p">)</span>
</code></pre>
</div>
<p>
 Это абсолютно нормальное и часто используемое поведение в Python.
</p>
<h3 id="1202-копирование-ссылок-и-сборка-мусора">
 1.20.2. Копирование ссылок и сборка мусора
</h3>
<p>
 Когда вы присваиваете одной переменной значение другой, вы не копируете сам объект, а лишь копируете ссылку на него.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="c1"># Теперь и x, и y ссылаются на один и тот же объект 5</span>
</code></pre>
</div>
<p>
 Так как числа (
 <code>
  int
 </code>
 ) неизменяемы, это абсолютно безопасно. Объект
 <code>
  5
 </code>
 в памяти один, а ссылаются на него две переменные.
</p>
<p>
 Интерпретатор Python отслеживает, сколько ссылок указывает на каждый объект. Когда на объект не остается ни одной ссылки, специальный механизм —
 <strong>
  сборщик мусора
 </strong>
 — автоматически удаляет этот объект из памяти, освобождая ресурсы.
</p>
<h3 id="1203-удаление-переменных">
 1.20.3. Удаление переменных
</h3>
<p>
 Вы можете принудительно удалить переменную (и, соответственно, одну ссылку на объект) с помощью инструкции
 <code>
  del
 </code>
 .
</p>
<blockquote>
 <p>
  <strong>
   Инструкция (Statement)
  </strong>
  — это команда, которая выполняет какое-либо действие, но не обязательно возвращает значение. Примеры: присваивание (
  <code>
   =
  </code>
  ),
  <code>
   del
  </code>
  ,
  <code>
   if
  </code>
  .
 </p>
</blockquote>
<div class="codehilite">
 <pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># Выведет 10</span>

<span class="k">del</span> <span class="n">x</span>

<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># Вызовет ошибку NameError: name 'x' is not defined</span>
</code></pre>
</div>
<p>
 Если на объект, на который ссылалась удаленная переменная, больше нет других ссылок, он будет удален сборщиком мусора.
</p>
<h1 id="глава-2-функции-преобразование-типов-и-операторы-сравнения">
 Глава 2: Функции, преобразование типов и операторы сравнения
</h1>
<h2 id="21-практическая-задача-автобусы-и-пассажиры">
 2.1. Практическая задача: Автобусы и пассажиры
</h2>
<p>
 Представим, что мы разрабатываем систему для автобусной станции. Есть общее количество купленных билетов на рейс (
 <code>
  num_tickets
 </code>
 ) и вместимость одного автобуса (
 <code>
  bus_capacity
 </code>
 ). Наша задача — определить, сколько полностью заполненных автобусов можно отправить и сколько пассажиров останется ждать следующего рейса.
</p>
<p>
 Такая чёткая постановка задачи наталкивает на мысль об использовании двух уже знакомых нам арифметических операторов:
</p>
<ol>
 <li>
  <strong>
   Целочисленное деление (
   <code>
    //
   </code>
   )
  </strong>
  : Поможет определить количество полностью заполненных автобусов.
 </li>
 <li>
  <strong>
   Остаток от деления (
   <code>
    %
   </code>
   )
  </strong>
  : Поможет определить количество "оставшихся" пассажиров, которым не хватило места для формирования полного автобуса.
 </li>
</ol>
<p>
 Реализуем это в коде:
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Исходные данные</span>
<span class="n">num_tickets</span> <span class="o">=</span> <span class="mi">237</span>  <span class="c1"># Количество купленных билетов</span>
<span class="n">bus_capacity</span> <span class="o">=</span> <span class="mi">48</span>  <span class="c1"># Вместимость одного автобуса</span>

<span class="c1"># 1. Вычисляем количество полностью заполненных автобусов</span>
<span class="n">full_buses_quantity</span> <span class="o">=</span> <span class="n">num_tickets</span> <span class="o">//</span> <span class="n">bus_capacity</span>

<span class="c1"># 2. Вычисляем количество оставшихся пассажиров</span>
<span class="n">tickets_left</span> <span class="o">=</span> <span class="n">num_tickets</span> <span class="o">%</span> <span class="n">bus_capacity</span>

<span class="c1"># Выводим результат</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Полностью заполненных автобусов:"</span><span class="p">,</span> <span class="n">full_buses_quantity</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Пассажиров ожидают:"</span><span class="p">,</span> <span class="n">tickets_left</span><span class="p">)</span>
</code></pre>
</div>
<p>
 Вывод:
</p>
<pre><code>Полностью заполненных автобусов: 4
Пассажиров ожидают: 45
</code></pre>
<p>
 Этот пример отлично демонстрирует, как правильный выбор инструментов решает задачу в одно действие. Хотя эту задачу можно решить и другими способами (с которыми мы познакомимся позже), на данном этапе использование операторов
 <code>
  //
 </code>
 и
 <code>
  %
 </code>
 является наиболее оптимальным решением.
</p>
<h2 id="22-введение-в-функции-концепция-и-назначение">
 2.2. Введение в функции: концепция и назначение
</h2>
<p>
 В коде часто возникают ситуации, когда один и тот же набор действий нужно выполнять многократно. Вместо того чтобы копировать и вставлять код, мы можем "упаковать" его в именованный блок и вызывать по имени.
</p>
<blockquote>
 <p>
  <strong>
   Функция (Function)
  </strong>
  — это именованный, многократно используемый блок кода, который выполняет определенную задачу. Функция может принимать входные данные (аргументы) и возвращать результат выполнения.
 </p>
</blockquote>
<p>
 Мы уже использовали встроенные функции, такие как
 <code>
  print()
 </code>
 . За этим именем закреплён код, который решает одну задачу: выводит данные в терминал. Функции позволяют не только избегать дублирования, но и структурировать программу, делая её более читаемой.
</p>
<h3 id="встроенные-и-импортируемые-функции">
 Встроенные и импортируемые функции
</h3>
<p>
 Python обладает огромным набором готовых решений, которые хранятся в
 <strong>
  стандартной библиотеке
 </strong>
 .
</p>
<blockquote>
 <p>
  <strong>
   Стандартная библиотека (Standard Library)
  </strong>
  — это набор модулей и функций, поставляемых вместе с Python. Она предоставляет инструменты для решения широкого круга задач без необходимости устанавливать дополнительные пакеты.
 </p>
</blockquote>
<p>
 Часть наиболее часто используемых функций (например,
 <code>
  print()
 </code>
 ,
 <code>
  round()
 </code>
 ,
 <code>
  input()
 </code>
 ) являются
 <strong>
  встроенными
 </strong>
 и доступны в любом месте программы без дополнительных действий.
</p>
<p>
 Другие функции сгруппированы в
 <strong>
  модули
 </strong>
 по тематическому признаку (например, математические функции в модуле
 <code>
  math
 </code>
 ). Чтобы их использовать, модуль нужно сначала
 <strong>
  импортировать
 </strong>
 в наш файл.
</p>
<blockquote>
 <p>
  <strong>
   Модуль (Module)
  </strong>
  — это файл с расширением
  <code>
   .py
  </code>
  , содержащий код на Python (функции, классы, переменные). Модули можно импортировать в другие файлы для повторного использования их содержимого.
 </p>
 <p>
  <strong>
   Импорт (Import)
  </strong>
  — это процесс подключения одного модуля (файла) к другому, чтобы сделать доступными функции и другие объекты из импортируемого модуля.
 </p>
</blockquote>
<p>
 Импорт обычно выполняется в самом верху файла с помощью ключевого слова
 <code>
  import
 </code>
 :
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Импортируем модуль с математическими функциями</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
</code></pre>
</div>
<h2 id="23-полезные-встроенные-функции-и-возвращаемое-значение">
 2.3. Полезные встроенные функции и возвращаемое значение
</h2>
<p>
 Давайте познакомимся с несколькими полезными функциями, которые пригодятся нам в дальнейшем.
</p>
<h3 id="231-округление-чисел-round">
 2.3.1. Округление чисел:
 <code>
  round()
 </code>
</h3>
<p>
 Встроенная функция
 <code>
  round()
 </code>
 позволяет округлять числа. Она принимает два аргумента:
</p>
<ol>
 <li>
  <code>
   number
  </code>
  — число, которое нужно округлить.
 </li>
 <li>
  <code>
   ndigits
  </code>
  (необязательный) — количество знаков после запятой, до которого нужно округлить. Если не указан, округление происходит до ближайшего целого числа (
  <code>
   int
  </code>
  ).
 </li>
</ol>
<blockquote>
 <p>
  <strong>
   Аргумент (Argument)
  </strong>
  — это конкретное значение, которое передается в функцию при её вызове для обработки.
 </p>
</blockquote>
<div class="codehilite">
 <pre><span></span><code><span class="n">result</span> <span class="o">=</span> <span class="mi">237</span> <span class="o">/</span> <span class="mi">48</span>  <span class="c1"># Получаем 4.9375</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="c1"># Округляем до двух знаков после запятой</span>
<span class="n">rounded_result_1</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rounded_result_1</span><span class="p">)</span>  <span class="c1"># Выведет: 4.94</span>

<span class="c1"># Округляем до целого числа</span>
<span class="n">rounded_result_2</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rounded_result_2</span><span class="p">)</span>  <span class="c1"># Выведет: 5</span>
</code></pre>
</div>
<p>
 <strong>
  Особенности
  <code>
   round()
  </code>
  и банковское округление
 </strong>
</p>
<p>
 При округлении чисел, находящихся ровно посередине (например, 2.5 или 4.5),
 <code>
  round()
 </code>
 использует стратегию "банковского округления".
</p>
<blockquote>
 <p>
  <strong>
   Банковское округление (Banker's Rounding)
  </strong>
  — это метод, при котором число, находящееся ровно посередине между двумя целыми, округляется до ближайшего
  <em>
   чётного
  </em>
  числа. Например,
  <code>
   round(2.5)
  </code>
  вернет
  <code>
   2
  </code>
  , а
  <code>
   round(3.5)
  </code>
  вернет
  <code>
   4
  </code>
  . Этот метод помогает уменьшить статистическую погрешность при большом количестве операций округления.
 </p>
</blockquote>
<p>
 Также на работу
 <code>
  round()
 </code>
 влияет неточность представления
 <code>
  float
 </code>
 чисел. Например, число
 <code>
  4.55
 </code>
 в памяти может храниться как
 <code>
  4.54999...
 </code>
 , поэтому при округлении до одного знака мы можем получить
 <code>
  4.5
 </code>
 , а не
 <code>
  4.6
 </code>
 , как ожидалось. В большинстве повседневных задач эти нюансы не критичны, но для высокоточных вычислений (финансовых, научных) используют специальные типы данных, например
 <code>
  Decimal
 </code>
 .
</p>
<h3 id="232-математические-операции-модуль-math">
 2.3.2. Математические операции: модуль
 <code>
  math
 </code>
</h3>
<p>
 Для более предсказуемого округления всегда в большую или меньшую сторону можно использовать функции из модуля
 <code>
  math
 </code>
 :
</p>
<ul>
 <li>
  <code>
   math.ceil()
  </code>
  (от ceiling - потолок) — округляет число до ближайшего целого
  <strong>
   в большую сторону
  </strong>
  .
 </li>
 <li>
  <code>
   math.floor()
  </code>
  (от floor - пол) — округляет число до ближайшего целого
  <strong>
   в меньшую сторону
  </strong>
  .
 </li>
</ul>
<p>
 Чтобы их использовать, сначала импортируем модуль
 <code>
  math
 </code>
 , а затем обращаемся к функциям через точку (точечная нотация):
 <code>
  имя_модуля.имя_функции
 </code>
 .
</p>
<div class="codehilite">
 <pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">math</span>

<span class="n">number</span> <span class="o">=</span> <span class="mf">4.1</span>

<span class="c1"># Округление "вверх"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">number</span><span class="p">))</span>  <span class="c1"># Выведет: 5</span>

<span class="c1"># Округление "вниз"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number</span><span class="p">))</span> <span class="c1"># Выведет: 4</span>
</code></pre>
</div>
<p>
 Эти функции можно использовать как альтернативу оператору
 <code>
  //
 </code>
 для решения нашей задачи с автобусами:
</p>
<div class="codehilite">
 <pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">math</span>

<span class="n">num_tickets</span> <span class="o">=</span> <span class="mi">237</span>
<span class="n">bus_capacity</span> <span class="o">=</span> <span class="mi">48</span>

<span class="c1"># Обычное деление</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">num_tickets</span> <span class="o">/</span> <span class="n">bus_capacity</span> <span class="c1"># 4.9375</span>

<span class="c1"># Количество автобусов, чтобы увезти ВСЕХ пассажиров</span>
<span class="n">total_buses</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">total_buses</span><span class="p">)</span> <span class="c1"># Выведет: 5</span>

<span class="c1"># Количество ПОЛНОСТЬЮ заполненных автобусов</span>
<span class="n">full_buses</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">full_buses</span><span class="p">)</span> <span class="c1"># Выведет: 4</span>
</code></pre>
</div>
<h3 id="233-получение-данных-от-пользователя-input">
 2.3.3. Получение данных от пользователя:
 <code>
  input()
 </code>
</h3>
<p>
 Функция
 <code>
  input()
 </code>
 приостанавливает выполнение программы и ждёт, пока пользователь введёт текст с клавиатуры и нажмёт
 <code>
  Enter
 </code>
 .
</p>
<ul>
 <li>
  <strong>
   Важнейшая особенность:
  </strong>
  <code>
   input()
  </code>
  <strong>
   всегда
  </strong>
  возвращает данные в виде строки (
  <code>
   str
  </code>
  ), даже если пользователь ввёл цифры.
 </li>
 <li>
  В качестве необязательного аргумента функция может принимать строку-приглашение (
  <code>
   prompt
  </code>
  ), которая будет показана пользователю.
 </li>
</ul>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Приглашаем пользователя ввести имя и сохраняем ввод в переменную</span>
<span class="n">user_name</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"Введите ваше имя: "</span><span class="p">)</span>

<span class="c1"># Используем полученные данные</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Привет, "</span> <span class="o">+</span> <span class="n">user_name</span> <span class="o">+</span> <span class="s2">"!"</span><span class="p">)</span>
</code></pre>
</div>
<p>
 При запуске этого кода вы увидите в терминале
 <code>
  Введите ваше имя:
 </code>
 . После ввода имени и нажатия
 <code>
  Enter
 </code>
 , программа продолжит выполнение и напечатает приветствие.
</p>
<h3 id="234-проверка-типа-данных-type">
 2.3.4. Проверка типа данных:
 <code>
  type()
 </code>
</h3>
<p>
 Чтобы узнать тип объекта, на который ссылается переменная, можно использовать встроенную функцию
 <code>
  type()
 </code>
 .
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">user_input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"Введите что-нибудь: "</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">user_input</span><span class="p">))</span>

<span class="n">number</span> <span class="o">=</span> <span class="mi">100</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">number</span><span class="p">))</span>
</code></pre>
</div>
<p>
 Вывод:
</p>
<pre><code>Введите что-нибудь: 123
&lt;class 'str'&gt;
&lt;class 'int'&gt;
</code></pre>
<p>
 Обратите внимание, что
 <code>
  type()
 </code>
 возвращает
 <code>
  class 'str'
 </code>
 , а не просто
 <code>
  str
 </code>
 . В Python типы данных реализованы через механизм классов. На данном этапе можно считать слова "тип" и "класс" синонимами.
</p>
<h3 id="235-возвращаемое-значение-функции">
 2.3.5. Возвращаемое значение функции
</h3>
<p>
 Некоторые функции, такие как
 <code>
  round()
 </code>
 или
 <code>
  input()
 </code>
 , создают или вычисляют новый объект и "возвращают" его в то место, где были вызваны. Мы сохраняем этот результат в переменную.
</p>
<blockquote>
 <p>
  <strong>
   Возвращаемое значение (Return Value)
  </strong>
  — это объект, который функция "отправляет назад" в основную программу после завершения своей работы. Этот объект можно присвоить переменной или сразу использовать в других операциях.
 </p>
</blockquote>
<p>
 А что возвращает функция
 <code>
  print()
 </code>
 ? Давайте проверим:
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">result</span> <span class="o">=</span> <span class="nb">print</span><span class="p">(</span><span class="s2">"Hello"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre>
</div>
<p>
 Вывод:
</p>
<pre><code>Hello
None
</code></pre>
<p>
 <code>
  print()
 </code>
 выполняет свою основную задачу (выводит "Hello" в терминал), но в качестве результата возвращает специальное значение
 <code>
  None
 </code>
 , которое означает "ничего" или "отсутствие значения".
</p>
<p>
 <strong>
  Вызов функции — это выражение
 </strong>
 . Поскольку любой вызов функции что-то возвращает (даже если это
 <code>
  None
 </code>
 ), его можно использовать в составе более сложных выражений.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Вызов round() возвращает число, которое мы тут же складываем с 10</span>
<span class="n">result</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="mf">23.3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1"># Выведет 33.0</span>
</code></pre>
</div>
<p>
 Python сначала выполнит внутреннюю операцию (вызов
 <code>
  round()
 </code>
 ), получит её результат (
 <code>
  23.0
 </code>
 ) и только потом выполнит сложение.
</p>
<h2 id="24-явное-преобразование-типов-casting">
 2.4. Явное преобразование типов (Casting)
</h2>
<p>
 Поскольку
 <code>
  input()
 </code>
 всегда возвращает строку, попытка выполнить математическую операцию с её результатом приведёт к ошибке:
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">user_num_str</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"Введите число: "</span><span class="p">)</span> <span class="c1"># Пользователь вводит "25"</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">user_num_str</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1"># Ошибка! Попытка сложить строку "25" и число 2</span>
<span class="c1"># TypeError: can only concatenate str (not "int") to str</span>
</code></pre>
</div>
<p>
 Чтобы решить эту проблему, нужно явно преобразовать (сконвертировать) строку в число.
</p>
<blockquote>
 <p>
  <strong>
   Преобразование типов (Type Casting/Conversion)
  </strong>
  — это процесс создания нового объекта одного типа на основе значения объекта другого типа (например, создание числа
  <code>
   int
  </code>
  из строки
  <code>
   str
  </code>
  ).
 </p>
</blockquote>
<p>
 Для этого существуют специальные встроенные функции-конструкторы, имена которых совпадают с названиями типов:
</p>
<ul>
 <li>
  <code>
   int()
  </code>
  : пытается создать целое число.
 </li>
 <li>
  <code>
   float()
  </code>
  : пытается создать число с плавающей точкой.
 </li>
 <li>
  <code>
   str()
  </code>
  : создаёт строку из любого другого типа.
 </li>
</ul>
<div class="codehilite">
 <pre><span></span><code><span class="n">user_num_str</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"Введите число: "</span><span class="p">)</span> <span class="c1"># Пользователь вводит "25"</span>

<span class="c1"># Преобразуем строку в целое число</span>
<span class="n">user_num_int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">user_num_str</span><span class="p">)</span>

<span class="c1"># Теперь математическая операция работает</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">user_num_int</span> <span class="o">+</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1"># Выведет: 27</span>
</code></pre>
</div>
<p>
 Можно объединить эти действия, "обернув" вызов одной функции в другую:
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Сразу преобразуем результат input() в число</span>
<span class="n">user_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s2">"Введите целое число: "</span><span class="p">))</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">user_num</span> <span class="o">+</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre>
</div>
<h3 id="нюансы-преобразования">
 Нюансы преобразования
</h3>
<ul>
 <li>
  <code>
   int()
  </code>
  сможет сконвертировать строку, только если она содержит исключительно символы, составляющие целое число (
  <code>
   "123"
  </code>
  ,
  <code>
   "-5"
  </code>
  ). Строка
  <code>
   "12.5"
  </code>
  вызовет ошибку
  <code>
   ValueError
  </code>
  .
 </li>
 <li>
  <code>
   float()
  </code>
  более гибок и может сконвертировать как
  <code>
   "12"
  </code>
  , так и
  <code>
   "12.5"
  </code>
  . Однако разделителем должна быть точка (
  <code>
   .
  </code>
  ), а не запятая.
 </li>
 <li>
  При преобразовании
  <code>
   float
  </code>
  в
  <code>
   int
  </code>
  дробная часть просто
  <strong>
   отбрасывается
  </strong>
  , а не округляется:
  <code>
   int(5.99)
  </code>
  вернёт
  <code>
   5
  </code>
  .
 </li>
</ul>
<h2 id="25-за-кулисами-как-данные-хранятся-в-памяти">
 2.5. За кулисами: как данные хранятся в памяти
</h2>
<p>
 Может показаться, что преобразование строки
 <code>
  "5"
 </code>
 в число
 <code>
  5
 </code>
 — это просто "удаление кавычек". На самом деле, это сложный процесс, потому что текст и числа представлены в памяти компьютера совершенно по-разному.
</p>
<h3 id="251-двоичная-система-биты-и-баиты">
 2.5.1. Двоичная система: биты и байты
</h3>
<p>
 На самом низком уровне компьютер оперирует только двумя состояниями: есть электрический сигнал (1) или его нет (0). Это
 <strong>
  двоичная система счисления
 </strong>
 .
</p>
<blockquote>
 <p>
  <strong>
   Бит (Bit)
  </strong>
  — это наименьшая единица информации в компьютере, принимающая значение 0 или 1.
 </p>
 <p>
  <strong>
   Байт (Byte)
  </strong>
  — это единица информации, состоящая из 8 битов. Байт является стандартной "ячейкой" для измерения объёма данных.
 </p>
</blockquote>
<p>
 Один байт (8 бит) может представить 256 различных значений (от 0 до 255). Комбинируя байты, можно представить абсолютно любое число.
</p>
<h3 id="252-кодировки-символов-от-ascii-до-utf-8">
 2.5.2. Кодировки символов: от ASCII до UTF-8
</h3>
<p>
 Чтобы представлять текст, была создана специальная таблица, которая сопоставляет каждому символу уникальное число.
</p>
<blockquote>
 <p>
  <strong>
   Кодировка (Encoding)
  </strong>
  — это набор правил для преобразования символов (букв, цифр, знаков) в числовые коды и обратно.
 </p>
</blockquote>
<blockquote>
 <p>
  <strong>
   ASCII
  </strong>
  — один из первых стандартов кодировки, который описывал 128 символов, в основном для английского алфавита, цифр и знаков препинания. Например, заглавная буква
  <code>
   A
  </code>
  в ASCII — это число 65, а символ
  <code>
   5
  </code>
  — это число 53.
 </p>
</blockquote>
<blockquote>
 <p>
  <strong>
   UTF-8
  </strong>
  — это современный стандарт кодировки, который включает в себя символы практически всех языков мира. Он обратно совместим с ASCII: первые 128 символов в UTF-8 полностью совпадают с таблицей ASCII.
 </p>
</blockquote>
<p>
 Таким образом, когда мы пишем в коде
 <code>
  A
 </code>
 , в памяти на самом деле хранится число
 <code>
  65
 </code>
 . А когда мы пишем строку
 <code>
  "25"
 </code>
 , в памяти хранятся два числа: код символа
 <code>
  2
 </code>
 (это 50) и код символа
 <code>
  5
 </code>
 (это 53).
</p>
<h3 id="253-функции-ord-и-chr">
 2.5.3. Функции
 <code>
  ord()
 </code>
 и
 <code>
  chr()
 </code>
</h3>
<p>
 В Python есть две функции для ручного преобразования между символом и его числовым кодом:
</p>
<ul>
 <li>
  <code>
   ord()
  </code>
  (от ordinal - порядковый): принимает символ (строку длиной 1) и возвращает его числовой код.
 </li>
 <li>
  <code>
   chr()
  </code>
  (от character - символ): принимает число и возвращает соответствующий ему символ.
 </li>
</ul>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Получаем числовой код символа 'A'</span>
<span class="n">code_a</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">'A'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">code_a</span><span class="p">)</span>  <span class="c1"># Выведет: 65</span>

<span class="c1"># Получаем символ по его коду</span>
<span class="n">char_65</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">65</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">char_65</span><span class="p">)</span> <span class="c1"># Выведет: A</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">'5'</span><span class="p">))</span> <span class="c1"># Выведет: 53</span>
</code></pre>
</div>
<p>
 Теперь становится понятно, почему преобразование строки в число — это нетривиальная операция. Функция
 <code>
  int("25")
 </code>
 выполняет примерно следующий алгоритм:
</p>
<ol>
 <li>
  Берёт первый символ
  <code>
   '2'
  </code>
  , получает его код
  <code>
   ord('2')
  </code>
  (это 50).
 </li>
 <li>
  Вычитает код нуля
  <code>
   ord('0')
  </code>
  (это 48), чтобы получить числовое значение:
  <code>
   50 - 48 = 2
  </code>
  .
 </li>
 <li>
  Берёт следующий символ
  <code>
   '5'
  </code>
  , получает его код
  <code>
   ord('5')
  </code>
  (это 53).
 </li>
 <li>
  Вычитает
  <code>
   48
  </code>
  :
  <code>
   53 - 48 = 5
  </code>
  .
 </li>
 <li>
  Собирает итоговое число:
  <code>
   2 * 10 + 5 = 25
  </code>
  .
 </li>
</ol>
<p>
 К счастью, Python делает всё это за нас автоматически.
</p>
<h2 id="26-булев-тип-и-операторы-сравнения">
 2.6. Булев тип и операторы сравнения
</h2>
<p>
 В основе логики любой программы лежит концепция "истины" и "лжи". В Python для этого существует специальный тип данных
 <code>
  bool
 </code>
 .
</p>
<h3 id="261-значения-true-и-false">
 2.6.1. Значения
 <code>
  True
 </code>
 и
 <code>
  False
 </code>
</h3>
<p>
 Тип
 <code>
  bool
 </code>
 (булев) имеет всего два возможных значения:
</p>
<ul>
 <li>
  <code>
   True
  </code>
  — истина (внутренне соответствует числу 1).
 </li>
 <li>
  <code>
   False
  </code>
  — ложь (внутренне соответствует числу 0).
 </li>
</ul>
<p>
 Эти значения являются ключевыми словами и пишутся с большой буквы.
</p>
<h3 id="262-концепция-истинности-truthiness">
 2.6.2. Концепция истинности (Truthiness)
</h3>
<p>
 В Python любое значение можно оценить в булевом контексте, то есть определить, является ли оно "истинным" (
 <code>
  True
 </code>
 ) или "ложным" (
 <code>
  False
 </code>
 ). Для этого можно использовать функцию
 <code>
  bool()
 </code>
 .
</p>
<blockquote>
 <p>
  <strong>
   Истинность (Truthiness)
  </strong>
  — это свойство любого объекта в Python быть расцененным как
  <code>
   True
  </code>
  или
  <code>
   False
  </code>
  в логическом контексте.
 </p>
</blockquote>
<p>
 <strong>
  Правила простые. Считаются ложными (
  <code>
   False
  </code>
  ):
 </strong>
</p>
<ul>
 <li>
  Число
  <code>
   0
  </code>
  (и
  <code>
   0.0
  </code>
  ).
 </li>
 <li>
  Пустая строка
  <code>
   ""
  </code>
  .
 </li>
 <li>
  Пустые коллекции (списки, словари и т.д., с которыми познакомимся позже).
 </li>
 <li>
  Специальное значение
  <code>
   None
  </code>
  .
 </li>
</ul>
<p>
 <strong>
  Всё остальное считается истинным (
  <code>
   True
  </code>
  ),
 </strong>
 включая любые ненулевые числа (даже отрицательные) и любые непустые строки (даже строка из пробела
 <code>
  " "
 </code>
 ).
</p>
<div class="codehilite">
 <pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>     <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">))</span>      <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>       <span class="c1"># False</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="s2">"hello"</span><span class="p">))</span> <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="s2">" "</span><span class="p">))</span>     <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="s2">""</span><span class="p">))</span>      <span class="c1"># False</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>    <span class="c1"># False</span>
</code></pre>
</div>
<h3 id="263-операторы-сравнения">
 2.6.3. Операторы сравнения
</h3>
<p>
 Для получения булевых значений на основе сравнения данных используются специальные операторы.
</p>
<blockquote>
 <p>
  <strong>
   Операторы сравнения (Comparison Operators)
  </strong>
  — это символы, используемые для сравнения двух значений. Результатом такой операции всегда является булево значение:
  <code>
   True
  </code>
  или
  <code>
   False
  </code>
  .
 </p>
</blockquote>
<table>
 <thead>
  <tr>
   <th style="text-align:left;">
    Оператор
   </th>
   <th style="text-align:left;">
    Описание
   </th>
   <th style="text-align:left;">
    Пример
   </th>
   <th style="text-align:left;">
    Результат
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td style="text-align:left;">
    <code>
     ==
    </code>
   </td>
   <td style="text-align:left;">
    Равно
   </td>
   <td style="text-align:left;">
    <code>
     5 == 5
    </code>
   </td>
   <td style="text-align:left;">
    <code>
     True
    </code>
   </td>
  </tr>
  <tr>
   <td style="text-align:left;">
    <code>
     !=
    </code>
   </td>
   <td style="text-align:left;">
    Не равно
   </td>
   <td style="text-align:left;">
    <code>
     5 != 6
    </code>
   </td>
   <td style="text-align:left;">
    <code>
     True
    </code>
   </td>
  </tr>
  <tr>
   <td style="text-align:left;">
    <code>
     &gt;
    </code>
   </td>
   <td style="text-align:left;">
    Больше
   </td>
   <td style="text-align:left;">
    <code>
     5 &gt; 4
    </code>
   </td>
   <td style="text-align:left;">
    <code>
     True
    </code>
   </td>
  </tr>
  <tr>
   <td style="text-align:left;">
    <code>
     &lt;
    </code>
   </td>
   <td style="text-align:left;">
    Меньше
   </td>
   <td style="text-align:left;">
    <code>
     5 &lt; 4
    </code>
   </td>
   <td style="text-align:left;">
    <code>
     False
    </code>
   </td>
  </tr>
  <tr>
   <td style="text-align:left;">
    <code>
     &gt;=
    </code>
   </td>
   <td style="text-align:left;">
    Больше или равно
   </td>
   <td style="text-align:left;">
    <code>
     5 &gt;= 5
    </code>
   </td>
   <td style="text-align:left;">
    <code>
     True
    </code>
   </td>
  </tr>
  <tr>
   <td style="text-align:left;">
    <code>
     &lt;=
    </code>
   </td>
   <td style="text-align:left;">
    Меньше или равно
   </td>
   <td style="text-align:left;">
    <code>
     5 &lt;= 4
    </code>
   </td>
   <td style="text-align:left;">
    <code>
     False
    </code>
   </td>
  </tr>
 </tbody>
</table>
<p>
 <strong>
  Важно:
 </strong>
 Не путайте оператор присваивания
 <code>
  =
 </code>
 (один знак равно) с оператором сравнения на равенство
 <code>
  ==
 </code>
 (два знака равно).
</p>
<p>
 Как и любой другой оператор, оператор сравнения создает выражение, результат которого можно сохранить в переменную:
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">is_equal</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">is_equal</span><span class="p">)</span> <span class="c1"># Выведет: False</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">is_equal</span><span class="p">))</span> <span class="c1"># Выведет: &lt;class 'bool'&gt;</span>
</code></pre>
</div>
<p>
 Эти операторы — ключ к созданию условий, циклов и управлению потоком выполнения программы, о чем мы поговорим в следующих главах.
</p>
<h2 id="27-дополнительные-операторы-и-сравнение-строк">
 2.7. Дополнительные операторы и сравнение строк
</h2>
<p>
 Помимо базовых операторов, Python предоставляет инструменты для более сложных сравнений, особенно при работе со строками и проверке вхождений.
</p>
<h3 id="271-завершение-знакомства-с-операторами-сравнения">
 2.7.1. Завершение знакомства с операторами сравнения
</h3>
<p>
 В дополнение к операторам, рассмотренным ранее, существуют их комбинации и оператор неравенства:
</p>
<table>
 <thead>
  <tr>
   <th style="text-align:left;">
    Оператор
   </th>
   <th style="text-align:left;">
    Описание
   </th>
   <th style="text-align:left;">
    Пример
   </th>
   <th style="text-align:left;">
    Результат
   </th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td style="text-align:left;">
    <code>
     &lt;=
    </code>
   </td>
   <td style="text-align:left;">
    Меньше или равно
   </td>
   <td style="text-align:left;">
    <code>
     5 &lt;= 5
    </code>
   </td>
   <td style="text-align:left;">
    <code>
     True
    </code>
   </td>
  </tr>
  <tr>
   <td style="text-align:left;">
    <code>
     !=
    </code>
   </td>
   <td style="text-align:left;">
    Не равно
   </td>
   <td style="text-align:left;">
    <code>
     5 != 6
    </code>
   </td>
   <td style="text-align:left;">
    <code>
     True
    </code>
   </td>
  </tr>
 </tbody>
</table>
<p>
 Оператор
 <code>
  !=
 </code>
 (не равно) является логической противоположностью оператору
 <code>
  ==
 </code>
 (равно). Он возвращает
 <code>
  True
 </code>
 , если операнды не равны, и
 <code>
  False
 </code>
 , если они равны.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Проверяем, что x не равно 5.</span>
<span class="c1"># Условие будет истинным для любого значения x, кроме 5.</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">is_not_five</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">is_not_five</span><span class="p">)</span>  <span class="c1"># Выведет: True</span>

<span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">is_not_five</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">is_not_five</span><span class="p">)</span>  <span class="c1"># Выведет: False</span>
</code></pre>
</div>
<h3 id="272-приоритет-операторов-и-комбинация-с-арифметикои">
 2.7.2. Приоритет операторов и комбинация с арифметикой
</h3>
<p>
 Как и у арифметических операторов, у операторов сравнения есть свой приоритет выполнения. Важно помнить, что
 <strong>
  все арифметические операции выполняются раньше, чем операции сравнения
 </strong>
 .
</p>
<p>
 Это позволяет создавать сложные выражения без использования скобок:
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Python сначала посчитает 2 + 2, получит 4,</span>
<span class="c1"># и только потом сравнит результат с 5.</span>
<span class="n">result</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">5</span>  <span class="c1"># Эквивалентно (2 + 2) &gt; 5</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1"># Выведет: False</span>
</code></pre>
</div>
<h3 id="273-цепочечные-сравнения">
 2.7.3. Цепочечные сравнения
</h3>
<p>
 Уникальной особенностью Python является поддержка
 <strong>
  цепочечных сравнений
 </strong>
 , что позволяет элегантно проверять, входит ли значение в определённый диапазон.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># Проверяем, что x находится в диапазоне от 2 (не включая) до 10 (не включая)</span>
<span class="n">is_in_range</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span>

<span class="nb">print</span><span class="p">(</span><span class="n">is_in_range</span><span class="p">)</span> <span class="c1"># Выведет: True</span>
</code></pre>
</div>
<p>
 В отличие от последовательных вычислений (например,
 <code>
  2 + 3 + 4
 </code>
 ), цепочечные сравнения работают иначе. Python не вычисляет
 <code>
  2 &lt; x
 </code>
 и потом сравнивает полученный
 <code>
  True
 </code>
 /
 <code>
  False
 </code>
 с
 <code>
  10
 </code>
 . Вместо этого, выражение
 <code>
  2 &lt; x &lt; 10
 </code>
 разворачивается в эквивалент
 <code>
  (2 &lt; x) and (x &lt; 10)
 </code>
 . Оба сравнения должны вернуть
 <code>
  True
 </code>
 , чтобы итоговый результат был
 <code>
  True
 </code>
 . С логическим оператором
 <code>
  and
 </code>
 мы познакомимся чуть позже.
</p>
<h3 id="274-сравнение-строк-лексикографическии-порядок">
 2.7.4. Сравнение строк: лексикографический порядок
</h3>
<p>
 Операторы сравнения (
 <code>
  ==
 </code>
 ,
 <code>
  !=
 </code>
 ,
 <code>
  &gt;
 </code>
 ,
 <code>
  &lt;
 </code>
 ) работают и со строками. Равенство проверяется просто: строки равны, если они состоят из одних и тех же символов в том же порядке и регистре.
</p>
<p>
 Сравнение "больше-меньше" происходит
 <strong>
  лексикографически
 </strong>
 , то есть посимвольно, на основе числовых кодов символов в таблице Unicode (которая включает в себя ASCII).
</p>
<blockquote>
 <p>
  <strong>
   Лексикографическое сравнение (Lexicographical Comparison)
  </strong>
  — это метод сравнения строк, при котором поочерёдно сравниваются числовые коды каждого символа. Сравнение останавливается на первой паре различающихся символов, и результат этого сравнения определяет, какая строка "больше".
 </p>
</blockquote>
<div class="codehilite">
 <pre><span></span><code><span class="n">url</span> <span class="o">=</span> <span class="s2">"www.google.com"</span>
<span class="n">broken_url</span> <span class="o">=</span> <span class="s2">"wXw.google.com"</span>

<span class="c1"># Сравнение остановится на втором символе:</span>
<span class="c1"># ord('w') == 119</span>
<span class="c1"># ord('X') == 88</span>
<span class="c1"># Поскольку 119 &gt; 88, строка url будет "больше" broken_url</span>
<span class="nb">print</span><span class="p">(</span><span class="n">url</span> <span class="o">&gt;</span> <span class="n">broken_url</span><span class="p">)</span> <span class="c1"># Выведет: True</span>

<span class="c1"># Если бы мы сравнивали 'w' и 'x':</span>
<span class="c1"># ord('x') == 120</span>
<span class="c1"># Поскольку 119 &lt; 120, то url был бы "меньше"</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"www"</span> <span class="o">&lt;</span> <span class="s2">"wxw"</span><span class="p">)</span> <span class="c1"># Выведет: True</span>
</code></pre>
</div>
<p>
 Проверка продолжается до конца самой короткой строки. Если одна строка является началом другой (например, "apple" и "applepie"), то более длинная строка считается "больше".
</p>
<h3 id="275-оператор-принадлежности-in">
 2.7.5. Оператор принадлежности
 <code>
  in
 </code>
</h3>
<p>
 Оператор
 <code>
  in
 </code>
 позволяет проверить, является ли одна строка частью (подстрокой) другой. Результатом всегда является булево значение.
</p>
<blockquote>
 <p>
  <strong>
   Подстрока (Substring)
  </strong>
  — это непрерывная последовательность символов внутри другой, более длинной строки. Для успешной проверки на вхождение и символы, и их порядок должны в точности совпадать.
 </p>
</blockquote>
<div class="codehilite">
 <pre><span></span><code><span class="n">url</span> <span class="o">=</span> <span class="s2">"www.google.com"</span>

<span class="c1"># Проверяем, есть ли "www" в строке url</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"www"</span> <span class="ow">in</span> <span class="n">url</span><span class="p">)</span> <span class="c1"># Выведет: True</span>

<span class="c1"># Проверяем, есть ли "com"</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"com"</span> <span class="ow">in</span> <span class="n">url</span><span class="p">)</span> <span class="c1"># Выведет: True</span>

<span class="c1"># Символы 'w' и 'c' есть, но не в такой последовательности</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"wc"</span> <span class="ow">in</span> <span class="n">url</span><span class="p">)</span>  <span class="c1"># Выведет: False</span>
</code></pre>
</div>
<p>
 Существует и противоположный оператор
 <code>
  not in
 </code>
 , который возвращает
 <code>
  True
 </code>
 , если подстрока
 <strong>
  не найдена
 </strong>
 :
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">url</span> <span class="o">=</span> <span class="s2">"www.google.com"</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"https"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">url</span><span class="p">)</span> <span class="c1"># Выведет: True</span>
</code></pre>
</div>
<p>
 Запись
 <code>
  a not in b
 </code>
 является более читаемым синонимом для
 <code>
  not (a in b)
 </code>
 .
</p>
<h2 id="28-логическое-отрицание-not-и-его-поведение">
 2.8. Логическое отрицание
 <code>
  not
 </code>
 и его поведение
</h2>
<p>
 Оператор
 <code>
  not
 </code>
 — это унарный логический оператор, который
 <strong>
  инвертирует
 </strong>
 булево значение своего операнда.
</p>
<ul>
 <li>
  <code>
   not True
  </code>
  становится
  <code>
   False
  </code>
  .
 </li>
 <li>
  <code>
   not False
  </code>
  становится
  <code>
   True
  </code>
  .
 </li>
</ul>
<p>
 У оператора
 <code>
  not
 </code>
 более низкий приоритет, чем у операторов сравнения, поэтому он применяется к результату их работы.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">is_equal</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="c1"># is_equal равно True</span>
<span class="n">inverted_result</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">is_equal</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inverted_result</span><span class="p">)</span> <span class="c1"># Выведет: False</span>

<span class="c1"># Можно записать в одну строку</span>
<span class="nb">print</span><span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">))</span> <span class="c1"># 5 &gt; 10 это False. not False -&gt; True</span>
</code></pre>
</div>
<h3 id="особенность-работы-not-с-любыми-типами">
 Особенность работы
 <code>
  not
 </code>
 с любыми типами
</h3>
<p>
 Оператор
 <code>
  not
 </code>
 может работать не только с готовыми
 <code>
  True
 </code>
 /
 <code>
  False
 </code>
 , но и с любыми другими объектами. В этом случае алгоритм работы такой:
</p>
<ol>
 <li>
  Python определяет "истинность" (
  <code>
   Truthiness
  </code>
  ) операнда, неявно преобразуя его в
  <code>
   bool
  </code>
  .
 </li>
 <li>
  Полученное булево значение инвертируется.
 </li>
</ol>
<div class="codehilite">
 <pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># Истинное значение (True)</span>
<span class="nb">print</span><span class="p">(</span><span class="ow">not</span> <span class="n">x</span><span class="p">)</span> <span class="c1"># not True -&gt; False</span>

<span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Ложное значение (False)</span>
<span class="nb">print</span><span class="p">(</span><span class="ow">not</span> <span class="n">y</span><span class="p">)</span> <span class="c1"># not False -&gt; True</span>

<span class="n">z</span> <span class="o">=</span> <span class="s2">""</span> <span class="c1"># Пустая строка, ложное значение (False)</span>
<span class="nb">print</span><span class="p">(</span><span class="ow">not</span> <span class="n">z</span><span class="p">)</span> <span class="c1"># not False -&gt; True</span>
</code></pre>
</div>
<p>
 Эта особенность часто используется в условных конструкциях для проверки наличия или отсутствия значения.
</p>
<h2 id="29-объектная-модель-python-классы-память-и-методы">
 2.9. Объектная модель Python: классы, память и методы
</h2>
<p>
 До сих пор мы рассматривали переменные и данные как простые сущности. Однако, чтобы понять, как Python достигает своей гибкости и мощи, необходимо заглянуть "под капот". В основе языка лежит последовательная и строгая объектно-ориентированная модель, где почти всё, с чем мы работаем, является объектом.
</p>
<h3 id="291-переменные-и-объекты-как-это-устроено">
 2.9.1. Переменные и объекты: как это устроено?
</h3>
<p>
 В отличие от некоторых других языков, переменная в Python не содержит сами данные и даже не хранит их прямой адрес в памяти. Вместо этого, переменная указывает на специальный
 <strong>
  прокси-объект
 </strong>
 .
</p>
<blockquote>
 <p>
  <strong>
   Прокси-объект (Proxy Object)
  </strong>
  — это промежуточный служебный объект, который находится между переменной и фактическими данными в памяти. Этот объект хранит метаинформацию о данных, управляя доступом к ним.
 </p>
</blockquote>
<p>
 Этот прокси-объект содержит три ключевых компонента:
</p>
<ul>
 <li>
  <strong>
   Значение (Value):
  </strong>
  Ссылка на реальные данные, которые хранятся где-то в памяти.
 </li>
 <li>
  <strong>
   Счётчик ссылок (Reference Count):
  </strong>
  Число, показывающее, сколько переменных в данный момент указывают на этот объект.
 </li>
 <li>
  <strong>
   Тип (Type):
  </strong>
  Информация о типе данных (например,
  <code>
   str
  </code>
  ,
  <code>
   int
  </code>
  ), которая определяет, как можно работать с этим значением.
 </li>
</ul>
<p>
 Эта структура объясняет одну из важнейших особенностей Python —
 <strong>
  динамическую типизацию
 </strong>
 .
</p>
<blockquote>
 <p>
  <strong>
   Динамическая типизация (Dynamic Typing)
  </strong>
  — это свойство языка программирования, при котором тип переменной определяется в момент присвоения ей значения (во время выполнения программы), а не при её объявлении. Переменная может менять свой тип в ходе выполнения программы.
 </p>
</blockquote>
<p>
 Поскольку тип хранится в самом объекте, а не в переменной,
 <strong>
  интерпретатору
 </strong>
 всегда известно, как обращаться с данными, на которые указывает переменная. Саму переменную можно воспринимать как "имя" или "указатель" на этот управляющий объект. Все сложности по работе с адресами памяти и доступом к значениям берёт на себя интерпретатор.
</p>
<blockquote>
 <p>
  <strong>
   Интерпретатор (Interpreter)
  </strong>
  — это программа, которая выполняет инструкции, написанные на языке программирования, поочерёдно, без предварительной компиляции всего кода в машинные инструкции.
 </p>
</blockquote>
<h3 id="292-классы-как-конструкторы-объектов">
 2.9.2. Классы как конструкторы объектов
</h3>
<p>
 Когда мы видим в выводе функции
 <code>
  type()
 </code>
 надпись
 <code>
  &lt;class 'int'&gt;
 </code>
 или
 <code>
  &lt;class 'str'&gt;
 </code>
 , это не случайно. В Python понятия "тип" и "
 <strong>
  класс
 </strong>
 " являются синонимами.
</p>
<blockquote>
 <p>
  <strong>
   Класс (Class)
  </strong>
  — это шаблон или чертёж для создания объектов. Он определяет набор атрибутов (данных) и методов (функций), которыми будут обладать созданные на его основе объекты.
 </p>
</blockquote>
<p>
 Базовые типы данных, такие как
 <code>
  int
 </code>
 ,
 <code>
  str
 </code>
 ,
 <code>
  float
 </code>
 и
 <code>
  bool
 </code>
 , на самом деле являются классами, реализованными на языке C как часть самого интерпретатора. Когда мы пишем
 <code>
  int()
 </code>
 , мы не просто вызываем функцию преобразования, мы используем класс
 <code>
  int
 </code>
 как конструктор для создания нового
 <strong>
  объекта
 </strong>
 в памяти.
</p>
<blockquote>
 <p>
  <strong>
   Объект (Object)
  </strong>
  — это конкретный экземпляр класса, представляющий собой сущность в памяти с определённым состоянием (данными) и поведением (методами). В Python практически всё является объектом: числа, строки, функции и даже сами классы.
 </p>
</blockquote>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Вызов класса int() как конструктора создаёт объект целого числа со значением 0</span>
<span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">()</span> 
<span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># Выведет: 0</span>

<span class="c1"># Вызов класса str() создаёт объект пустой строки</span>
<span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1"># Выведет пустую строку</span>
</code></pre>
</div>
<h3 id="293-методы-встроенные-функции-объектов">
 2.9.3. Методы: встроенные функции объектов
</h3>
<p>
 Одно из главных преимуществ объектного подхода заключается в том, что классы содержат не только логику создания объектов, но и
 <strong>
  методы
 </strong>
 — специальные функции для работы с данными этих объектов.
</p>
<blockquote>
 <p>
  <strong>
   Метод (Method)
  </strong>
  — это функция, которая принадлежит классу и вызывается для конкретного экземпляра этого класса. Методы имеют доступ к данным объекта и могут их изменять или использовать для вычислений.
 </p>
</blockquote>
<p>
 Доступ к методам осуществляется через "точечную нотацию" после переменной, хранящей объект.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">s</span> <span class="o">=</span> <span class="s2">"Привет, Мир!"</span>

<span class="c1"># Обращаемся к переменной s, ставим точку и вызываем метод lower()</span>
<span class="c1"># Этот метод принадлежит классу str и возвращает новую строку в нижнем регистре</span>
<span class="n">new_s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="n">new_s</span><span class="p">)</span> <span class="c1"># Выведет: "привет, мир!"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>     <span class="c1"># Старая строка осталась без изменений: "Привет, Мир!"</span>
</code></pre>
</div>
<p>
 Когда интерпретатор видит
 <code>
  s.lower()
 </code>
 , он выполняет следующую последовательность действий:
</p>
<ol>
 <li>
  Находит объект, на который ссылается переменная
  <code>
   s
  </code>
  .
 </li>
 <li>
  Смотрит на тип этого объекта (в данном случае,
  <code>
   str
  </code>
  ).
 </li>
 <li>
  Ищет в определении класса
  <code>
   str
  </code>
  метод с именем
  <code>
   lower
  </code>
  .
 </li>
 <li>
  Если метод найден, он вызывается, и его код выполняется над данными объекта
  <code>
   s
  </code>
  .
 </li>
</ol>
<h3 id="294-резюме-ключевых-понятии">
 2.9.4. Резюме ключевых понятий
</h3>
<ul>
 <li>
  <strong>
   Природа языка:
  </strong>
  Python — объектно-ориентированный язык. Мы работаем не с примитивными данными, а с объектами, у которых есть заранее определённое поведение (методы).
 </li>
 <li>
  <strong>
   Класс:
  </strong>
  Чертеж или конструктор, который создаёт объекты и содержит методы для работы с ними.
 </li>
 <li>
  <strong>
   Объект:
  </strong>
  Любые данные в памяти (
  <code>
   5
  </code>
  ,
  <code>
   "hello"
  </code>
  ), содержащие информацию о своём классе-создателе и счётчик ссылок.
 </li>
 <li>
  <strong>
   Экземпляр класса (Class Instance):
  </strong>
  Синоним слова "объект", который подчёркивает, что объект был создан по конкретному шаблону (классу). Например, переменная
  <code>
   s = "Hello"
  </code>
  является экземпляром класса
  <code>
   str
  </code>
  . Шаблон (
  <code>
   str
  </code>
  ) один, а экземпляров (разных строк) может быть создано множество.
 </li>
 <li>
  <strong>
   Метод:
  </strong>
  Функция внутри класса, доступная через его экземпляры и предназначенная для воздействия на данные объекта.
 </li>
</ul>
<h2 id="210-управление-памятью-и-жизненныи-цикл-объектов">
 2.10. Управление памятью и жизненный цикл объектов
</h2>
<p>
 Понимание того, как Python управляет памятью, является ключом к написанию эффективного и предсказуемого кода.
</p>
<h3 id="2101-сборщик-мусора-и-счетчик-ссылок">
 2.10.1. Сборщик мусора и счётчик ссылок
</h3>
<p>
 Как мы уже знаем, каждый объект в памяти имеет счётчик ссылок. Этот счётчик увеличивается каждый раз, когда новая переменная начинает указывать на объект, и уменьшается, когда переменная перестаёт на него ссылаться (например, ей присваивается другое значение или она удаляется с помощью
 <code>
  del
 </code>
 ).
</p>
<p>
 В Python работает автоматический
 <strong>
  сборщик мусора
 </strong>
 .
</p>
<blockquote>
 <p>
  <strong>
   Сборщик мусора (Garbage Collector)
  </strong>
  — это автоматический механизм управления памятью, который находит и освобождает память, занятую объектами, на которые больше не существует ссылок в программе.
 </p>
</blockquote>
<p>
 Как только счётчик ссылок объекта достигает нуля, сборщик мусора удаляет этот объект из памяти, освобождая ресурсы. Это избавляет программиста от необходимости вручную управлять выделением и освобождением памяти.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="s2">"AAA"</span>  <span class="c1"># Создан объект "AAA", счётчик ссылок = 1 (переменная x)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span>      <span class="c1"># Теперь на тот же объект ссылается и y, счётчик ссылок = 2</span>

<span class="k">del</span> <span class="n">x</span>      <span class="c1"># Удаляем переменную x, счётчик ссылок = 1 (осталась y)</span>

<span class="c1"># Объект "AAA" продолжает существовать, так как на него есть ссылка y</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>   <span class="c1"># Выведет: AAA </span>
</code></pre>
</div>
<h3 id="2102-оператор-is-и-функция-id-проверка-идентичности-объектов">
 2.10.2. Оператор
 <code>
  is
 </code>
 и функция
 <code>
  id()
 </code>
 : проверка идентичности объектов
</h3>
<p>
 Чтобы проверить, указывают ли две переменные на один и тот же объект в памяти, используется оператор
 <code>
  is
 </code>
 . Он сравнивает не значения, а идентификаторы объектов. Получить этот идентификатор (который обычно является адресом объекта в памяти) можно с помощью встроенной функции
 <code>
  id()
 </code>
 .
</p>
<ul>
 <li>
  <code>
   x == y
  </code>
  проверяет,
  <strong>
   равны ли значения
  </strong>
  объектов.
 </li>
 <li>
  <code>
   x is y
  </code>
  проверяет, являются ли
  <code>
   x
  </code>
  и
  <code>
   y
  </code>
  <strong>
   одним и тем же объектом
  </strong>
  .
 </li>
</ul>
<p>
 Это различие критически важно. Можно создать два разных объекта с абсолютно одинаковыми значениями.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Создаем первый объект через литерал</span>
<span class="n">x</span> <span class="o">=</span> <span class="s2">"AAA"</span> 

<span class="c1"># Создаем второй, внешне идентичный объект через ввод пользователя</span>
<span class="c1"># Функция input() всегда создает новый объект строки</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"Введите 'AAA': "</span><span class="p">)</span> <span class="c1"># Вводим AAA</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Значения равны: </span><span class="si">{</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># Выведет: Значения равны: True</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Объекты идентичны: </span><span class="si">{</span><span class="n">x</span><span class="w"> </span><span class="ow">is</span><span class="w"> </span><span class="n">y</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># Выведет: Объекты идентичны: False</span>

<span class="c1"># Проверим их идентификаторы</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"ID объекта x: </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"ID объекта y: </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># Адреса будут разными</span>
</code></pre>
</div>
<h3 id="2103-механизмы-оптимизации-памяти">
 2.10.3. Механизмы оптимизации памяти
</h3>
<p>
 Для повышения производительности Python использует несколько умных механизмов оптимизации при работе с неизменяемыми типами данных (числа, строки,
 <code>
  bool
 </code>
 ,
 <code>
  None
 </code>
 ).
</p>
<h4 id="интернирование-объектов">
 Интернирование объектов
</h4>
<blockquote>
 <p>
  <strong>
   Интернирование объектов (Object Interning)
  </strong>
  — это метод оптимизации, при котором интерпретатор заранее создаёт единственный, "вечный" объект для некоторых часто используемых неизменяемых значений. Все переменные с этим значением будут ссылаться на этот один и тот же объект.
 </p>
</blockquote>
<p>
 При запуске интерпретатор Python заранее создаёт и хранит в памяти:
</p>
<ul>
 <li>
  Целые числа в диапазоне от -5 до 256.
 </li>
 <li>
  Булевы значения
  <code>
   True
  </code>
  и
  <code>
   False
  </code>
  .
 </li>
 <li>
  Объект
  <code>
   None
  </code>
  .
 </li>
 <li>
  Некоторые короткие строки, используемые самим интерпретатором.
 </li>
</ul>
<p>
 Это означает, что сколько бы раз в вашем коде ни встретилось число
 <code>
  5
 </code>
 , все переменные будут указывать на один и тот же объект пятёрки в памяти, что экономит ресурсы.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># Это значение интернировано</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s2">"Введите 5: "</span><span class="p">))</span> <span class="c1"># Вводим 5</span>

<span class="c1"># Несмотря на динамическое создание, Python достаточно умён,</span>
<span class="c1"># чтобы найти и использовать уже существующий интернированный объект</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"x is y: </span><span class="si">{</span><span class="n">x</span><span class="w"> </span><span class="ow">is</span><span class="w"> </span><span class="n">y</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># Выведет: x is y: True</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"id(x) == id(y): </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">id</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># Выведет: id(x) == id(y): True</span>
</code></pre>
</div>
<h4 id="кэширование-литералов">
 Кэширование литералов
</h4>
<p>
 Помимо интернирования, Python также кэширует
 <strong>
  литералы
 </strong>
 , которые встречаются в коде.
</p>
<blockquote>
 <p>
  <strong>
   Литерал (Literal)
  </strong>
  — это способ записи фиксированного значения непосредственно в исходном коде программы. Например,
  <code>
   100
  </code>
  ,
  <code>
   "hello"
  </code>
  и
  <code>
   True
  </code>
  являются литералами.
 </p>
</blockquote>
<p>
 Если вы записываете в коде одно и то же значение (даже если оно не входит в диапазон интернирования) несколько раз, интерпретатор может создать для него один объект и поместить его в кэш. Последующие использования этого литерала будут ссылаться на уже кэшированный объект.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Это число не входит в диапазон интернирования</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">5555</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">5555</span>

<span class="c1"># Так как оба значения - это литералы, записанные в коде,</span>
<span class="c1"># интерпретатор кэширует первый и использует его для второго.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="n">y</span><span class="p">)</span> <span class="c1"># Выведет: True</span>

<span class="c1"># То же самое работает для коротких строк-литералов</span>
<span class="n">s1</span> <span class="o">=</span> <span class="s2">"some_short_string"</span>
<span class="n">s2</span> <span class="o">=</span> <span class="s2">"some_short_string"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s1</span> <span class="ow">is</span> <span class="n">s2</span><span class="p">)</span> <span class="c1"># Выведет: True</span>
</code></pre>
</div>
<p>
 <strong>
  Важно:
 </strong>
 Изменяемые типы данных (списки, словари) никогда не кэшируются, даже если они записаны как литералы. Каждая запись
 <code>
  []
 </code>
 или
 <code>
  {}
 </code>
 создаст новый, уникальный объект.
</p>
<h2 id="211-практическая-работа-с-типами-данных">
 2.11. Практическая работа с типами данных
</h2>
<p>
 Вооружившись знаниями об объектах и методах, рассмотрим их практическое применение для работы с числами и строками.
</p>
<h3 id="2111-литералы-и-методы-числовых-типов">
 2.11.1. Литералы и методы числовых типов
</h3>
<p>
 Python позволяет форматировать числовые литералы для улучшения читаемости кода, не влияя на их итоговое значение.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Использование подчёркивания для разделения разрядов</span>
<span class="n">large_number</span> <span class="o">=</span> <span class="mi">50_000_000_000</span>
<span class="nb">print</span><span class="p">(</span><span class="n">large_number</span><span class="p">)</span> <span class="c1"># Выведет: 50000000000</span>

<span class="c1"># Упрощённая запись чисел с плавающей точкой</span>
<span class="n">num_float1</span> <span class="o">=</span> <span class="mf">.25</span>  <span class="c1"># Эквивалентно 0.25</span>
<span class="n">num_float2</span> <span class="o">=</span> <span class="mf">25.</span>  <span class="c1"># Эквивалентно 25.0</span>
<span class="nb">print</span><span class="p">(</span><span class="n">num_float1</span><span class="p">,</span> <span class="n">num_float2</span><span class="p">)</span> <span class="c1"># Выведет: 0.25 25.0</span>

<span class="c1"># Бинарный (двоичный) литерал</span>
<span class="n">binary_num</span> <span class="o">=</span> <span class="mb">0b1000001</span> <span class="c1"># 65 в двоичной системе</span>
<span class="nb">print</span><span class="p">(</span><span class="n">binary_num</span><span class="p">)</span> <span class="c1"># Выведет: 65</span>
</code></pre>
</div>
<p>
 Методы числовых типов используются реже, чем строковые, но один из них весьма полезен.
</p>
<p>
 <strong>
  Метод
  <code>
   is_integer()
  </code>
  для
  <code>
   float
  </code>
 </strong>
</p>
<p>
 Этот метод возвращает
 <code>
  True
 </code>
 , если число с плавающей точкой не имеет дробной части (т.е. после точки стоит ноль), и
 <code>
  False
 </code>
 в противном случае. Это полезно для безопасного преобразования
 <code>
  float
 </code>
 в
 <code>
  int
 </code>
 .
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">y</span> <span class="o">=</span> <span class="mf">25.0</span>

<span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">is_integer</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Число можно безопасно преобразовать в int"</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="c1"># Преобразуем в 25</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"У числа есть дробная часть, лучше округлить"</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="c1"># Выведет: 25</span>
</code></pre>
</div>
<h3 id="2112-основные-методы-строк">
 2.11.2. Основные методы строк
</h3>
<p>
 Строки обладают богатым набором методов для решения самых разнообразных задач. Все они возвращают
 <em>
  новую
 </em>
 строку или другое значение (
 <code>
  bool
 </code>
 ,
 <code>
  int
 </code>
 ), не изменяя исходную.
</p>
<h4 id="изменение-регистра">
 Изменение регистра
</h4>
<ul>
 <li>
  <code>
   lower()
  </code>
  : Переводит все символы строки в нижний регистр.
 </li>
 <li>
  <code>
   upper()
  </code>
  : Переводит все символы строки в верхний регистр.
 </li>
 <li>
  <code>
   capitalize()
  </code>
  : Делает первый символ заглавным, а все остальные — строчными. Идеально для имён и названий.
 </li>
 <li>
  <code>
   casefold()
  </code>
  : Более "агрессивная" версия
  <code>
   lower()
  </code>
  , предназначенная для сравнения строк без учёта регистра. Она корректно обрабатывает большее количество специфических символов Unicode.
 </li>
</ul>
<div class="codehilite">
 <pre><span></span><code><span class="n">user_input</span> <span class="o">=</span> <span class="s2">"пРиВет"</span>
<span class="n">template</span> <span class="o">=</span> <span class="s2">"привет"</span>

<span class="k">if</span> <span class="n">user_input</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">template</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Строки совпадают в нижнем регистре!"</span><span class="p">)</span>
</code></pre>
</div>
<h4 id="поиск-и-проверка">
 Поиск и проверка
</h4>
<ul>
 <li>
  <code>
   startswith(substr)
  </code>
  : Возвращает
  <code>
   True
  </code>
  , если строка начинается с подстроки
  <code>
   substr
  </code>
  .
 </li>
 <li>
  <code>
   endswith(substr)
  </code>
  : Возвращает
  <code>
   True
  </code>
  , если строка заканчивается на
  <code>
   substr
  </code>
  .
 </li>
 <li>
  <code>
   count(substr)
  </code>
  : Возвращает количество невложенных вхождений подстроки
  <code>
   substr
  </code>
  .
 </li>
</ul>
<div class="codehilite">
 <pre><span></span><code><span class="n">command</span> <span class="o">=</span> <span class="s2">"/start"</span>
<span class="k">if</span> <span class="n">command</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">"/"</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Это похоже на команду для бота."</span><span class="p">)</span>

<span class="n">text</span> <span class="o">=</span> <span class="s2">"раз, два, три, раз, два, четыре"</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Слово 'раз' встречается </span><span class="si">{</span><span class="n">text</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">'раз'</span><span class="p">)</span><span class="si">}</span><span class="s2"> раза."</span><span class="p">)</span> <span class="c1"># Выведет: 2</span>
</code></pre>
</div>
<h4 id="замена-и-модификация">
 Замена и модификация
</h4>
<ul>
 <li>
  <code>
   replace(old, new, [count])
  </code>
  : Заменяет все вхождения подстроки
  <code>
   old
  </code>
  на
  <code>
   new
  </code>
  . Необязательный аргумент
  <code>
   count
  </code>
  ограничивает количество замен.
 </li>
</ul>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Пример безопасного преобразования числа от пользователя</span>
<span class="n">user_number</span> <span class="o">=</span> <span class="s2">"2,55"</span> 

<span class="c1"># Заменяем запятую на точку для корректного преобразования во float</span>
<span class="n">corrected_number_str</span> <span class="o">=</span> <span class="n">user_number</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">","</span><span class="p">,</span> <span class="s2">"."</span><span class="p">)</span>
<span class="n">result_float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">corrected_number_str</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">result_float</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="c1"># Выведет: 12.55</span>

<span class="c1"># Пример замены только первого вхождения</span>
<span class="n">url</span> <span class="o">=</span> <span class="s2">"http://example.com/page?param=http"</span>
<span class="c1"># Заменяем только первый "http" на "https", указав count=1</span>
<span class="n">secure_url</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"http"</span><span class="p">,</span> <span class="s2">"https"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">secure_url</span><span class="p">)</span> <span class="c1"># Выведет: https://example.com/page?param=http</span>
</code></pre>
</div>
<h3 id="2113-индексы-и-срезы-доступ-к-элементам-последовательности">
 2.11.3. Индексы и срезы: доступ к элементам последовательности
</h3>
<p>
 Строки, как и другие последовательности в Python (списки, кортежи), позволяют получать доступ к своим элементам по их порядковому номеру (
 <strong>
  индексу
 </strong>
 ) или извлекать целые фрагменты (
 <strong>
  срезы
 </strong>
 ).
</p>
<h4 id="индексация">
 Индексация
</h4>
<blockquote>
 <p>
  <strong>
   Индекс (Index)
  </strong>
  — это числовое представление позиции элемента в упорядоченной последовательности. Нумерация в Python всегда начинается с нуля.
 </p>
</blockquote>
<ul>
 <li>
  <code>
   string[0]
  </code>
  — первый элемент.
 </li>
 <li>
  <code>
   string[1]
  </code>
  — второй элемент.
 </li>
 <li>
  <code>
   string[-1]
  </code>
  — последний элемент (отрицательная индексация идёт с конца).
 </li>
 <li>
  <code>
   string[-2]
  </code>
  — предпоследний элемент.
 </li>
</ul>
<div class="codehilite">
 <pre><span></span><code><span class="n">s</span> <span class="o">=</span> <span class="s2">"Python"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>   <span class="c1"># Выведет: P</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>   <span class="c1"># Выведет: h</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Выведет: n</span>
</code></pre>
</div>
<p>
 Попытка обратиться к несуществующему индексу вызовет ошибку
 <code>
  IndexError
 </code>
 .
</p>
<h4 id="срезы">
 Срезы
</h4>
<blockquote>
 <p>
  <strong>
   Срез (Slice)
  </strong>
  — это операция, которая извлекает непрерывный сегмент последовательности, создавая новую последовательность.
 </p>
</blockquote>
<p>
 Синтаксис среза:
 <code>
  [start:stop:step]
 </code>
</p>
<ul>
 <li>
  <code>
   start
  </code>
  : индекс, с которого начинается срез (включая его). По умолчанию — начало строки.
 </li>
 <li>
  <code>
   stop
  </code>
  : индекс, на котором срез заканчивается (
  <strong>
   не включая его
  </strong>
  ). По умолчанию — конец строки.
 </li>
 <li>
  <code>
   step
  </code>
  : шаг, с которым извлекаются элементы. По умолчанию — 1.
 </li>
</ul>
<div class="codehilite">
 <pre><span></span><code><span class="n">url</span> <span class="o">=</span> <span class="s2">"https://www.google.com"</span>

<span class="c1"># Взять срез с 8-го по 11-й символ (не включая 11-й)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">url</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">11</span><span class="p">])</span>  <span class="c1"># Выведет: www</span>

<span class="c1"># Взять срез с начала до 5-го символа</span>
<span class="nb">print</span><span class="p">(</span><span class="n">url</span><span class="p">[:</span><span class="mi">5</span><span class="p">])</span>    <span class="c1"># Выведет: https</span>

<span class="c1"># Взять срез с 12-го символа и до конца</span>
<span class="nb">print</span><span class="p">(</span><span class="n">url</span><span class="p">[</span><span class="mi">12</span><span class="p">:])</span>   <span class="c1"># Выведет: google.com</span>

<span class="c1"># Взять каждый второй символ из всей строки</span>
<span class="nb">print</span><span class="p">(</span><span class="n">url</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>   <span class="c1"># Выведет: htps/w.oge.o</span>

<span class="c1"># Получить перевёрнутую строку с помощью отрицательного шага</span>
<span class="nb">print</span><span class="p">(</span><span class="n">url</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Выведет: moc.elgoog.www//:sptth</span>
</code></pre>
</div>
<p>
 Индексы и срезы — мощнейший инструмент для парсинга и анализа данных, который широко применяется при работе не только со строками, но и с другими структурами данных в Python.
</p>
<p>
 Конечно, вот преобразованный и структурированный текст, соответствующий вашим требованиям.
</p>
<hr/>
<h3 id="212-углубленная-работа-со-строками">
 2.12. Углублённая работа со строками
</h3>
<p>
 В этом разделе мы глубже погрузимся в механику работы со строками: от продвинутых срезов до внутреннего устройства хранения символов в памяти. Эти знания помогут вам понять, почему строки в Python ведут себя определённым образом и как писать более эффективный код.
</p>
<h4 id="2121-продвинутые-срезы-отрицательныи-шаг">
 2.12.1. Продвинутые срезы: отрицательный шаг
</h4>
<p>
 Помимо стандартного использования срезов, существует возможность применять отрицательный шаг (
 <code>
  step
 </code>
 ). Это позволяет извлекать элементы последовательности в обратном порядке.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">s</span> <span class="o">=</span> <span class="s2">"123, 456"</span>

<span class="c1"># Шаг -1 означает, что срез будет двигаться от конца к началу</span>
<span class="c1"># В данном случае мы получим инвертированную строку</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># Выведет: '654 ,321'</span>
</code></pre>
</div>
<p>
 При использовании отрицательного шага важно помнить, что индексы
 <code>
  start
 </code>
 и
 <code>
  stop
 </code>
 тоже меняют свою логику:
 <code>
  start
 </code>
 должен быть больше, чем
 <code>
  stop
 </code>
 .
</p>
<blockquote>
 <p>
  <strong>
   Поинтер (Pointer)
  </strong>
  — в низкоуровневом программировании это переменная, которая хранит адрес ячейки памяти. Python скрывает прямую работу с поинтерами, но его внутренние механизмы активно их используют для быстрого доступа к данным.
 </p>
</blockquote>
<div class="codehilite">
 <pre><span></span><code><span class="n">s</span> <span class="o">=</span> <span class="s2">"123, 456"</span>

<span class="c1"># Возьмём срез от 3-го индекса до 1-го (не включая) в обратном порядке</span>
<span class="c1"># s[3] -&gt; ','</span>
<span class="c1"># s[2] -&gt; '3'</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># Выведет: ',3'</span>

<span class="c1"># Можно использовать и отрицательные индексы</span>
<span class="c1"># От -5-го элемента (' ') до -8-го ('2') в обратном порядке</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">8</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># Выведет: ' 32'</span>
</code></pre>
</div>
<p>
 Хотя работа с обратными срезами может показаться неинтуитивной, со временем вы привыкнете к этой логике. Главное — помнить, что отрицательный шаг инвертирует направление движения по последовательности.
</p>
<h3 id="213-внутреннее-устроиство-строк-память-и-кодировки">
 2.13. Внутреннее устройство строк: память и кодировки
</h3>
<p>
 Если вы внимательно изучали предыдущие разделы, у вас мог возникнуть вопрос: как Python так быстро находит элемент по индексу (
 <code>
  string[10]
 </code>
 ), если символы в строке могут занимать разный объём памяти (например, латиница — 1 байт, кириллица — 2 байта)? Ответ кроется в оптимизации хранения строк.
</p>
<h4 id="2131-кодировки-и-проблема-переменного-размера-символов">
 2.13.1. Кодировки и проблема переменного размера символов
</h4>
<p>
 Для представления символов в памяти используются кодировки. Наиболее распространённой является UTF-8.
</p>
<blockquote>
 <p>
  <strong>
   Кодировка UTF-8 (UTF-8 Encoding)
  </strong>
  — это стандарт кодирования символов, позволяющий представлять знаки практически всех письменных языков мира. Символы в нём имеют переменную длину: от 1 байта для латиницы (совместимой с ASCII) до 4 байт для редких символов и эмодзи.
 </p>
</blockquote>
<blockquote>
 <p>
  <strong>
   Кодировка ASCII (ASCII Encoding)
  </strong>
  — это исторически первая и наиболее простая кодировка, включающая 128 символов: латинские буквы, цифры и основные знаки препинания. Каждый символ в ASCII занимает ровно 1 байт.
 </p>
</blockquote>
<p>
 Когда интерпретатор Python считывает ваш код или получает данные (например, из сети), он работает с кодировкой UTF-8. Однако для внутреннего использования и быстрой работы он преобразует строки в собственный, оптимизированный формат.
</p>
<p>
 Проблема с UTF-8 для быстрого доступа по индексу заключается в том, что для нахождения 10-го символа пришлось бы последовательно "прощупать" первые 9, чтобы узнать их суммарную длину в байтах и найти начало 10-го. Это медленно и неэффективно.
</p>
<blockquote>
 <p>
  <strong>
   Константное время (Constant Time)
  </strong>
  — это характеристика алгоритма, время выполнения которого не зависит от размера входных данных. Доступ к элементу по индексу в Python является операцией, выполняемой за константное время.
 </p>
</blockquote>
<h4 id="2132-оптимизация-хранения-строк-в-python">
 2.13.2. Оптимизация хранения строк в Python
</h4>
<p>
 Чтобы обеспечить доступ по индексу за константное время, Python применяет хитрость: внутри памяти он выделяет на
 <strong>
  каждый
 </strong>
 символ строки одинаковое количество байт. Этот размер определяется самым "тяжёлым" символом в данной строке.
</p>
<ul>
 <li>
  Если строка содержит только символы ASCII (1 байт), каждый символ будет храниться в 1 байте.
 </li>
 <li>
  Если в строке появляется хотя бы один кириллический символ (2 байта), то
  <strong>
   все
  </strong>
  символы в этой строке, включая латинские, будут храниться в ячейках по 2 байта.
 </li>
 <li>
  Если в строке появляется эмодзи (4 байта), то все символы в ней будут занимать по 4 байта.
 </li>
</ul>
<p>
 Этот компромисс между использованием памяти и скоростью доступа позволяет интерпретатору мгновенно вычислять адрес нужного символа по формуле:
 <code>
  адрес_начала_строки + (индекс * размер_ячейки)
 </code>
 .
</p>
<h4 id="2133-практическая-проверка-метод-__sizeof__">
 2.13.3. Практическая проверка: метод
 <code>
  __sizeof__()
 </code>
</h4>
<p>
 Узнать, сколько байт занимает объект и содержащиеся в нём данные, можно с помощью специального метода
 <code>
  __sizeof__()
 </code>
 .
</p>
<blockquote>
 <p>
  <strong>
   Специальный метод (Special Method)
  </strong>
  — это метод в Python, имя которого начинается и заканчивается двойным подчёркиванием (например,
  <code>
   __sizeof__
  </code>
  ). Такие методы реализуют базовое поведение объектов и обычно не вызываются напрямую, а используются интерпретатором при выполнении определённых операций.
 </p>
</blockquote>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Размер объекта пустой строки (служебные данные)</span>
<span class="n">empty_str</span> <span class="o">=</span> <span class="s2">""</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Пустая строка: </span><span class="si">{</span><span class="n">empty_str</span><span class="o">.</span><span class="n">__sizeof__</span><span class="p">()</span><span class="si">}</span><span class="s2"> байт"</span><span class="p">)</span> <span class="c1"># ~49 байт (зависит от версии Python и ОС)</span>

<span class="c1"># Строка из 10 латинских символов (по 1 байту)</span>
<span class="n">ascii_str</span> <span class="o">=</span> <span class="s2">"a"</span> <span class="o">*</span> <span class="mi">10</span>
<span class="c1"># 49 байт (объект) + 10 * 1 байт (символы) + 1 байт (терминатор) = 60</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Строка ASCII: </span><span class="si">{</span><span class="n">ascii_str</span><span class="o">.</span><span class="n">__sizeof__</span><span class="p">()</span><span class="si">}</span><span class="s2"> байт"</span><span class="p">)</span>

<span class="c1"># Строка, где 9 латинских символов и 1 кириллический (2 байта)</span>
<span class="n">mixed_str</span> <span class="o">=</span> <span class="s2">"a"</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">+</span> <span class="s2">"б"</span>
<span class="c1"># Теперь каждый символ занимает 2 байта</span>
<span class="c1"># 49 + 10 * 2 + 1 = 70 (примерный расчёт, реальные значения могут отличаться)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Смешанная строка (кириллица): </span><span class="si">{</span><span class="n">mixed_str</span><span class="o">.</span><span class="n">__sizeof__</span><span class="p">()</span><span class="si">}</span><span class="s2"> байт"</span><span class="p">)</span>

<span class="c1"># Строка с эмодзи (4 байта)</span>
<span class="n">emoji_str</span> <span class="o">=</span> <span class="s2">"a"</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">+</span> <span class="s2">"😂"</span>
<span class="c1"># Теперь каждый символ занимает 4 байта</span>
<span class="c1"># 49 + 10 * 4 + 1 = 90</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Смешанная строка (эмодзи): </span><span class="si">{</span><span class="n">emoji_str</span><span class="o">.</span><span class="n">__sizeof__</span><span class="p">()</span><span class="si">}</span><span class="s2"> байт"</span><span class="p">)</span>
</code></pre>
</div>
<p>
 Когда Python возвращает вам строку для использования, он преобразует её обратно в стандартный формат (например, UTF-8), но все внутренние операции, такие как срезы и индексация, происходят над оптимизированным представлением.
</p>
<h3 id="214-обработка-строковых-литералов">
 2.14. Обработка строковых литералов
</h3>
<blockquote>
 <p>
  <strong>
   Строковый литерал (String Literal)
  </strong>
  — это последовательность символов в исходном коде, заключённая в кавычки (одинарные, двойные или тройные). Интерпретатор преобразует литералы в строковые объекты в памяти.
 </p>
</blockquote>
<p>
 Интерпретатор Python имеет несколько особенностей при обработке строковых литералов, которые полезно знать.
</p>
<h4 id="2141-автоматическое-объединение-литералов">
 2.14.1. Автоматическое объединение литералов
</h4>
<p>
 Если два или более строковых литерала идут в коде подряд (разделены только пробелами), Python автоматически объединит их в один объект. Это эффективнее, чем конкатенация через
 <code>
  +
 </code>
 , так как не создаются промежуточные объекты.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">s</span> <span class="o">=</span> <span class="s2">"Hello"</span> <span class="s2">" "</span> <span class="s2">"World"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1"># Выведет: Hello World</span>
</code></pre>
</div>
<h4 id="2142-перенос-длинных-строк">
 2.14.2. Перенос длинных строк
</h4>
<p>
 Согласно руководству по стилю кода
 <strong>
  PEP 8
 </strong>
 , длина строки в коде не должна превышать 79-99 символов для удобства чтения.
</p>
<blockquote>
 <p>
  <strong>
   PEP 8 (Python Enhancement Proposal 8)
  </strong>
  — это официальный документ, который содержит рекомендации по написанию чистого, читаемого и консистентного кода на Python. Следование этим правилам является стандартом в профессиональной разработке.
 </p>
</blockquote>
<p>
 Длинную строку можно разбить на несколько физических строк, объединив их в одну логическую.
</p>
<blockquote>
 <p>
  <strong>
   Физическая и логическая строка (Physical &amp; Logical Line)
  </strong>
  — физическая строка — это то, что вы видите как одну строку в текстовом редакторе. Логическая строка — это полная инструкция, которую Python выполняет как единое целое; она может занимать несколько физических строк.
 </p>
</blockquote>
<p>
 Способы переноса:
</p>
<ol>
 <li>
  <strong>
   Заключить в круглые скобки:
  </strong>
  <div class="codehilite">
   <pre><span></span><code><span class="n">long<em>string</em></span> <span class="o">=</span> <span class="p">(</span><span class="s2">"Это очень длинная строка, "</span>
               <span class="s2">"которую мы разделили на части."</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">longstring</span><span class="p">)</span>
</code></pre>
  </div>
 </li>
</ol>
<ol start="2">
 <li>
  <strong>
   Использовать символ обратного слэша (
   <code>
    \
   </code>
   ):
  </strong>
  <div class="codehilite">
   <pre><span></span><code><span class="n">another<em>long</em>string</span> <span class="o">=</span> <span class="s2">"Это тоже очень длинная строка, "</span>\
                      <span class="s2">"разделённая другим способом."</span>
<span class="nb">print</span><span class="p">(</span><span class="n">another<em>long</em>string</span><span class="p">)</span>
</code></pre>
  </div>
 </li>
</ol>
<p>
 Этот символ явно указывает, что логическая строка продолжается на следующей физической строке. Его можно применять не только к строкам, но и к длинным выражениям, например, в условиях
 <code>
  if
 </code>
 .
</p>
<h4 id="2143-многострочные-строки-троиные-кавычки">
 2.14.3. Многострочные строки (тройные кавычки)
</h4>
<p>
 Для создания строк, которые сохраняют все переносы и отступы, используются тройные кавычки (
 <code>
  """
 </code>
 или
 <code>
  '''
 </code>
 ).
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">multiline_text</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">Это многострочный</span>
<span class="s2">  текстовый блок.</span>
<span class="s2">Все переносы и отступы будут сохранены.</span>
<span class="s2">"""</span>
<span class="nb">print</span><span class="p">(</span><span class="n">multiline_text</span><span class="p">)</span>
</code></pre>
</div>
<p>
 Такие строки часто используются для написания документации к функциям и модулям (docstrings), так как они не кэшируются и удаляются из памяти после выполнения программы, не влияя на её производительность.
</p>
<h3 id="215-форматирование-строк">
 2.15. Форматирование строк
</h3>
<p>
 Форматирование — это процесс создания строк путём подстановки в них значений переменных или выражений. Это одна из самых частых задач в программировании.
</p>
<h4 id="2151-f-строки-современныи-стандарт">
 2.15.1. F-строки: современный стандарт
</h4>
<p>
 <strong>
  F-строки
 </strong>
 (форматированные строковые литералы) — это наиболее современный, удобный и производительный способ форматирования.
</p>
<blockquote>
 <p>
  <strong>
   F-строка (F-string)
  </strong>
  — это строковый литерал с префиксом
  <code>
   f
  </code>
  или
  <code>
   F
  </code>
  , который позволяет встраивать выражения Python непосредственно внутрь строки. Выражения заключаются в фигурные скобки
  <code>
   {}
  </code>
  .
 </p>
</blockquote>
<div class="codehilite">
 <pre><span></span><code><span class="n">name</span> <span class="o">=</span> <span class="s2">"Алиса"</span>
<span class="n">user_id</span> <span class="o">=</span> <span class="mi">101</span>

<span class="c1"># В фигурных скобках можно указывать переменные и любые выражения</span>
<span class="n">greeting</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"Привет, </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">! Ваш ID: </span><span class="si">{</span><span class="n">user_id</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span> <span class="c1"># Выведет: Привет, АЛИСА! Ваш ID: 102</span>
</code></pre>
</div>
<h4 id="2152-спецификаторы-форматирования">
 2.15.2. Спецификаторы форматирования
</h4>
<p>
 Внутри фигурных скобок можно использовать специальные команды для форматирования вывода, которые называются спецификаторами. Они записываются после двоеточия.
</p>
<blockquote>
 <p>
  <strong>
   Спецификатор форматирования (Format Specifier)
  </strong>
  — это специальный код, который управляет представлением значения при его преобразовании в строку. Он позволяет контролировать количество знаков после запятой, выравнивание, систему счисления и многое другое.
 </p>
</blockquote>
<div class="codehilite">
 <pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">math</span>

<span class="c1"># Округляем число Пи до 2 знаков после запятой</span>
<span class="c1"># .2f означает "оставить 2 знака для числа с плавающей точкой (float)"</span>
<span class="n">formatted_pi</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"Число Пи: </span><span class="si">{</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">formatted_pi</span><span class="p">)</span> <span class="c1"># Выведет: Число Пи: 3.14</span>
</code></pre>
</div>
<h4 id="2153-метод-format">
 2.15.3. Метод
 <code>
  format()
 </code>
</h4>
<p>
 До появления f-строк основным способом форматирования был метод
 <code>
  .format()
 </code>
 . Он применяется к строковому шаблону и подставляет переданные значения в места, отмеченные фигурными скобками
 <code>
  {}
 </code>
 .
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">name</span> <span class="o">=</span> <span class="s2">"Борис"</span>
<span class="n">rating</span> <span class="o">=</span> <span class="mf">4.9512</span>

<span class="c1"># Позиционная подстановка</span>
<span class="n">template_pos</span> <span class="o">=</span> <span class="s2">"Пользователь: </span><span class="si">{}</span><span class="s2">, Рейтинг: </span><span class="si">{:.1f}</span><span class="s2">"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">template_pos</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">rating</span><span class="p">))</span>

<span class="c1"># Именованная подстановка</span>
<span class="n">template_named</span> <span class="o">=</span> <span class="s2">"Пользователь: </span><span class="si">{user_name}</span><span class="s2">, Рейтинг: </span><span class="si">{user_rating:.1f}</span><span class="s2">"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">template_named</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">user_name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">user_rating</span><span class="o">=</span><span class="n">rating</span><span class="p">))</span>
</code></pre>
</div>
<p>
 <strong>
  Когда использовать
  <code>
   format()
  </code>
  ?
 </strong>
 Основное преимущество метода
 <code>
  format()
 </code>
 — возможность создать шаблон строки заранее и форматировать его позже, когда появятся нужные данные. F-строки форматируются немедленно в момент их определения.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Шаблон создаётся один раз</span>
<span class="n">message_template</span> <span class="o">=</span> <span class="s2">"Здравствуйте, </span><span class="si">{name}</span><span class="s2">! Ваш заказ #</span><span class="si">{order_id}</span><span class="s2"> готов."</span>

<span class="c1"># ...позже в программе...</span>
<span class="n">user1_name</span> <span class="o">=</span> <span class="s2">"Иван"</span>
<span class="n">order1_id</span> <span class="o">=</span> <span class="mi">123</span>
<span class="nb">print</span><span class="p">(</span><span class="n">message_template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">user1_name</span><span class="p">,</span> <span class="n">order_id</span><span class="o">=</span><span class="n">order1_id</span><span class="p">))</span>

<span class="n">user2_name</span> <span class="o">=</span> <span class="s2">"Мария"</span>
<span class="n">order2_id</span> <span class="o">=</span> <span class="mi">124</span>
<span class="nb">print</span><span class="p">(</span><span class="n">message_template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">user2_name</span><span class="p">,</span> <span class="n">order_id</span><span class="o">=</span><span class="n">order2_id</span><span class="p">))</span>
</code></pre>
</div>
<h4 id="2154-старыи-стиль-форматирования-оператор">
 2.15.4. Старый стиль форматирования (оператор
 <code>
  %
 </code>
 )
</h4>
<p>
 В старых версиях Python (и в коде, унаследованном с тех времён) вы можете встретить форматирование с помощью оператора
 <code>
  %
 </code>
 . Он похож на аналогичный механизм в языке C.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">name</span> <span class="o">=</span> <span class="s2">"Виктор"</span>
<span class="n">rating</span> <span class="o">=</span> <span class="mf">3.5</span>

<span class="c1"># %s - подстановка строки, %.1f - подстановка float с 1 знаком после запятой</span>
<span class="n">old_style</span> <span class="o">=</span> <span class="s2">"Пользователь: </span><span class="si">%s</span><span class="s2">, Рейтинг: </span><span class="si">%.1f</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">rating</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">old_style</span><span class="p">)</span>
</code></pre>
</div>
<blockquote>
 <p>
  <strong>
   Кортеж (Tuple)
  </strong>
  — это неизменяемая упорядоченная коллекция элементов, которая записывается в круглых скобках. Мы подробно изучим кортежи в следующих разделах.
 </p>
</blockquote>
<p>
 <strong>
  Использовать этот стиль в новом коде не рекомендуется.
 </strong>
 F-строки и метод
 <code>
  format()
 </code>
 являются более гибкими, читаемыми и безопасными.
</p>
<h3 id="216-экранирование-служебных-символов">
 2.16. Экранирование служебных символов
</h3>
<p>
 Иногда в строке нужно использовать символы, которые имеют специальное значение, например, кавычки или обратный слэш. Для этого используется механизм экранирования.
</p>
<blockquote>
 <p>
  <strong>
   Экранирование (Escaping)
  </strong>
  — это способ "обезвредить" специальный символ, поставив перед ним обратный слэш (
  <code>
   \
  </code>
  ). Это говорит интерпретатору, что следующий за слэшем символ нужно воспринимать буквально, а не как часть синтаксиса.
 </p>
</blockquote>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Одинарная кавычка внутри строки, обрамлённой одинарными кавычками</span>
<span class="n">text</span> <span class="o">=</span> <span class="s1">'It</span><span class="se">\'</span><span class="s1">s a beautiful day.'</span>
<span class="nb">print</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="c1"># Выведет: It's a beautiful day.</span>
</code></pre>
</div>
<h4 id="2161-управляющие-последовательности">
 2.16.1. Управляющие последовательности
</h4>
<p>
 Комбинация обратного слэша с определёнными символами образует
 <strong>
  управляющие последовательности
 </strong>
 , которые не выводятся на экран, а выполняют специальные действия.
</p>
<blockquote>
 <p>
  <strong>
   Управляющая последовательность (Escape Sequence)
  </strong>
  — это комбинация из нескольких символов, начинающаяся с обратного слэша, которая представляет один специальный символ. Например,
  <code>
   \n
  </code>
  — это один символ переноса строки.
 </p>
</blockquote>
<p>
 Основные управляющие последовательности:
</p>
<ul>
 <li>
  <code>
   \n
  </code>
  — перенос на новую строку.
 </li>
 <li>
  <code>
   \t
  </code>
  — табуляция (отступ).
 </li>
 <li>
  <code>
   \\
  </code>
  — сам символ обратного слэша.
 </li>
 <li>
  <code>
   \'
  </code>
  — одинарная кавычка.
 </li>
 <li>
  <code>
   \"
  </code>
  — двойная кавычка.
 </li>
</ul>
<div class="codehilite">
 <pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="s2">"Первая строка</span><span class="se">\n</span><span class="s2">Вторая строка</span><span class="se">\t</span><span class="s2">с отступом."</span><span class="p">)</span>
</code></pre>
</div>
<h4 id="2162-практическии-пример-пути-в-windows">
 2.16.2. Практический пример: пути в Windows
</h4>
<p>
 Особый случай — пути к файлам в Windows, где в качестве разделителя используется обратный слэш. Это создаёт проблемы, так как комбинации вроде
 <code>
  \n
 </code>
 или
 <code>
  \t
 </code>
 будут восприняты как управляющие последовательности.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Неправильно: \n будет обработан как перенос строки</span>
<span class="n">wrong_path</span> <span class="o">=</span> <span class="s2">"C:\Users</span><span class="se">\n</span><span class="s2">ew_user\Desktop"</span> 
<span class="c1"># print(wrong_path) -&gt; приведёт к ошибке или неверному выводу</span>
</code></pre>
</div>
<p>
 <strong>
  Решения:
 </strong>
</p>
<ol>
 <li>
  <strong>
   Экранировать каждый слэш:
  </strong>
  <div class="codehilite">
   <pre><span></span><code><span class="n">path1</span> <span class="o">=</span> <span class="s2">"C:</span><span class="se">\</span><span class="s2">Users</span><span class="se">\</span><span class="s2">new_user</span><span class="se">\</span><span class="s2">Desktop"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">path1</span><span class="p">)</span>
</code></pre>
  </div>
 </li>
</ol>
<ol start="2">
 <li>
  <p>
   <strong>
    Использовать "сырые" строки (raw strings):
   </strong>
   Поставить префикс
   <code>
    r
   </code>
   перед строкой. В таких строках все обратные слэши теряют своё специальное значение.
   <strong>
    Это предпочтительный способ.
   </strong>
  </p>
  <div class="codehilite">
   <pre><span></span><code><span class="n">path2</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">"C:\Users\new_user\Desktop"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">path2</span><span class="p">)</span>
</code></pre>
  </div>
 </li>
 <li>
  <p>
   <strong>
    Использовать прямые слэши:
   </strong>
   Python на всех операционных системах, включая Windows, корректно работает с путями, где используются прямые слэши (
   <code>
    /
   </code>
   ).
  </p>
  <div class="codehilite">
   <pre><span></span><code><span class="n">path3</span> <span class="o">=</span> <span class="s2">"C:/Users/new_user/Desktop"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">path3</span><span class="p">)</span>
</code></pre>
  </div>
 </li>
</ol>
<h3 id="217-практическая-задача-палиндром">
 2.17. Практическая задача: «Палиндром»
</h3>
<p>
 Вооружившись знаниями о срезах, решим классическую задачу.
</p>
<blockquote>
 <p>
  <strong>
   Палиндром (Palindrome)
  </strong>
  — это слово, фраза или последовательность символов, которая читается одинаково как слева направо, так и справа налево. Примеры: "level", "топот", "madam".
 </p>
</blockquote>
<p>
 <strong>
  Задача:
 </strong>
 Написать код, который проверяет, является ли введённое слово палиндромом.
</p>
<p>
 <strong>
  Решение:
 </strong>
 Самый элегантный способ решения в Python — сравнить исходную строку с её перевёрнутой версией, полученной с помощью среза.
</p>
<blockquote>
 <p>
  <strong>
   Алгоритм (Algorithm)
  </strong>
  — это конечная последовательность чётко определённых инструкций для решения конкретной задачи. Сравнение строки с её инверсией — это простой и эффективный алгоритм проверки на палиндром.
 </p>
</blockquote>
<div class="codehilite">
 <pre><span></span><code><span class="n">word</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"Введите слово: "</span><span class="p">)</span>

<span class="c1"># С помощью среза [::-1] получаем перевёрнутую строку</span>
<span class="c1"># Сравниваем её с оригиналом. Результат (True или False) сохранится в переменную.</span>
<span class="n">is_palindrome</span> <span class="o">=</span> <span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">word</span><span class="o">.</span><span class="n">lower</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># Используем f-строку для вывода результата</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Слово '</span><span class="si">{</span><span class="n">word</span><span class="si">}</span><span class="s2">' является палиндромом: </span><span class="si">{</span><span class="n">is_palindrome</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre>
</div>
<p>
 <em>
  Примечание: мы используем
  <code>
   .lower()
  </code>
  для того, чтобы проверка была нечувствительной к регистру (например, чтобы "Level" тоже считался палиндромом).
 </em>
</p>
<p>
 Эта задача является прекрасным примером мощи и лаконичности Python. В дальнейшем мы вернёмся к ней и решим её другими способами, чтобы сравнить эффективность разных подходов.
</p>
<h3 id="218-введение-в-циклы-цикл-while">
 2.18. Введение в циклы: цикл
 <code>
  while
 </code>
</h3>
<p>
 До сих пор наши программы выполнялись линейно, команда за командой. Однако часто необходимо повторять определённый блок кода несколько раз. Для этого используются циклы.
</p>
<blockquote>
 <p>
  <strong>
   Цикл (Loop)
  </strong>
  — это управляющая конструкция в программировании, которая позволяет многократно выполнять блок кода (тело цикла) до тех пор, пока выполняется некоторое условие.
 </p>
</blockquote>
<p>
 В Python существует два типа циклов:
 <code>
  while
 </code>
 и
 <code>
  for
 </code>
 . Начнём с
 <code>
  while
 </code>
 .
</p>
<p>
 Цикл
 <code>
  while
 </code>
 (в переводе "пока") выполняет блок кода, пока его условие истинно (
 <code>
  True
 </code>
 ).
</p>
<h4 id="2181-структура-цикла-while">
 2.18.1. Структура цикла
 <code>
  while
 </code>
</h4>
<div class="codehilite">
 <pre><span></span><code><span class="k">while</span> <span class="n">условие</span><span class="p">:</span>
    <span class="c1"># Тело цикла: этот код выполняется, пока условие == True</span>
    <span class="c1"># ...</span>
    <span class="c1"># Здесь может быть оператор continue, чтобы пропустить остаток тела цикла</span>
    <span class="c1"># ...</span>
    <span class="c1"># Здесь может быть оператор break, чтобы немедленно выйти из цикла</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># Этот блок выполняется, если цикл завершился "естественно"</span>
    <span class="c1"># (то есть его условие стало False), а не был прерван оператором break.</span>
</code></pre>
</div>
<h4 id="2182-практическии-пример-валидация-пароля">
 2.18.2. Практический пример: валидация пароля
</h4>
<p>
 Рассмотрим классическую задачу: запрашивать у пользователя пароль, пока он не введёт пароль достаточной длины (например, не менее 8 символов).
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># 1. Запрашиваем пароль первый раз</span>
<span class="n">password</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"Придумайте пароль: "</span><span class="p">)</span>

<span class="c1"># 2. Запускаем цикл, который будет работать, пока длина пароля меньше 8</span>
<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">password</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Пароль должен содержать не менее 8 символов."</span><span class="p">)</span>
    <span class="c1"># Запрашиваем пароль снова внутри цикла</span>
    <span class="n">password</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"Попробуйте снова: "</span><span class="p">)</span>

<span class="c1"># 3. Этот код выполнится только после выхода из цикла</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Пароль принят!"</span><span class="p">)</span>
</code></pre>
</div>
<p>
 Каждый проход цикла называется
 <strong>
  итерацией
 </strong>
 .
</p>
<blockquote>
 <p>
  <strong>
   Итерация (Iteration)
  </strong>
  — это однократное выполнение тела цикла. В каждой итерации переменные могут изменяться, что в итоге влияет на условие завершения цикла.
 </p>
</blockquote>
<blockquote>
 <p>
  <strong>
   Тело цикла (Loop Body)
  </strong>
  — это блок кода с отступом, который находится внутри конструкции цикла. Именно этот код выполняется многократно.
 </p>
</blockquote>
<h4 id="2183-управление-циклом-break">
 2.18.3. Управление циклом:
 <code>
  break
 </code>
</h4>
<p>
 Иногда необходимо прервать цикл досрочно, даже если его основное условие всё ещё истинно. Для этого используется оператор
 <code>
  break
 </code>
 .
</p>
<p>
 Перепишем наш пример с паролем, используя "бесконечный цикл"
 <code>
  while True
 </code>
 и
 <code>
  break
 </code>
 для выхода.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="k">while</span> <span class="kc">True</span><span class="p">:</span> <span class="c1"># Этот цикл будет работать вечно, если его не прервать</span>
    <span class="n">password</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"Придумайте пароль (не менее 8 символов): "</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">password</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">:</span>
        <span class="c1"># Если условие выполнено, прерываем цикл</span>
        <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Если нет, выводим сообщение и цикл начинается заново</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Недостаточная длина пароля."</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Пароль успешно создан!"</span><span class="p">)</span>
</code></pre>
</div>
<p>
 Такая конструкция очень удобна, когда условие выхода из цикла удобнее проверять внутри его тела, а не в заголовке.
</p>
<h4 id="2184-другие-операторы-continue-и-else">
 2.18.4. Другие операторы:
 <code>
  continue
 </code>
 и
 <code>
  else
 </code>
</h4>
<ul>
 <li>
  <strong>
   <code>
    continue
   </code>
  </strong>
  : Этот оператор немедленно завершает
  <em>
   текущую итерацию
  </em>
  и переходит к проверке условия для следующей итерации. Код, написанный после
  <code>
   continue
  </code>
  в теле цикла, пропускается.
 </li>
 <li>
  <strong>
   <code>
    else
   </code>
  </strong>
  : Блок
  <code>
   else
  </code>
  в цикле
  <code>
   while
  </code>
  выполняется только в том случае, если цикл завершился естественным образом (его условие стало
  <code>
   False
  </code>
  ), а не был прерван оператором
  <code>
   break
  </code>
  .
 </li>
</ul>
<p>
 Рассмотрим пример подсчёта гласных букв в строке, используя индекс для перебора.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">user_input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"Введите текст: "</span><span class="p">)</span>
<span class="n">vowels</span> <span class="o">=</span> <span class="s2">"aeiouyAEIOUY"</span> <span class="c1"># Строка с гласными для проверки</span>

<span class="n">vowels_count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">user_input</span><span class="p">):</span>
    <span class="c1"># Берём символ по текущему индексу</span>
    <span class="n">char</span> <span class="o">=</span> <span class="n">user_input</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="c1"># Проверяем, есть ли символ в строке гласных</span>
    <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">vowels</span><span class="p">:</span>
        <span class="n">vowels_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Увеличиваем индекс для перехода к следующему символу на следующей итерации</span>
    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># Этот блок выполнится, когда цикл завершит перебор всех символов</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Подсчёт завершён успешно."</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Количество гласных в тексте: </span><span class="si">{</span><span class="n">vowels_count</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre>
</div>
<p>
 Этот пример показывает, как можно эмулировать перебор последовательности с помощью цикла
 <code>
  while
 </code>
 и переменной-счётчика (индекса). Хотя для таких задач лучше подходит цикл
 <code>
  for
 </code>
 , который мы рассмотрим далее, этот пример хорошо иллюстрирует механику работы
 <code>
  while
 </code>
 .
</p>
<p>
 Конечно, вот преобразованный и структурированный текст, соответствующий вашим требованиям.
</p>
<hr/>
<h3 id="219-расширенное-управление-циклами">
 2.19. Расширенное управление циклами
</h3>
<p>
 Помимо стандартного потока выполнения, циклы
 <code>
  while
 </code>
 предоставляют мощные инструменты для более гибкого управления их поведением: операторы
 <code>
  break
 </code>
 и
 <code>
  continue
 </code>
 , а также опциональный блок
 <code>
  else
 </code>
 . Эти конструкции позволяют обрабатывать особые случаи, прерывать выполнение или пропускать итерации, делая код более эффективным и читаемым.
</p>
<h4 id="2191-досрочныи-выход-из-цикла-оператор-break">
 2.19.1. Досрочный выход из цикла: оператор
 <code>
  break
 </code>
</h4>
<p>
 Оператор
 <code>
  break
 </code>
 немедленно и полностью прекращает выполнение цикла, в котором он находится. Управление передаётся первой же инструкции после тела цикла.
</p>
<blockquote>
 <p>
  <strong>
   Оператор
   <code>
    break
   </code>
   (Break Statement)
  </strong>
  — это ключевое слово, которое вызывает немедленное завершение самого внутреннего цикла (
  <code>
   for
  </code>
  или
  <code>
   while
  </code>
  ), в котором оно находится. Код в блоке
  <code>
   else
  </code>
  цикла при этом не выполняется.
 </p>
</blockquote>
<p>
 Рассмотрим игровой пример: пользователь должен вводить слова, и программа подсчитывает в них количество гласных букв. Однако, если в слове встречается буква «т» («t»), она действует как «стоп-буква», и все последующие гласные в этом слове игнорируются.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">user_input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"Введите слово: "</span><span class="p">)</span>
<span class="n">vowels</span> <span class="o">=</span> <span class="s2">"aeiouyAEIOUY"</span>
<span class="n">vowels_count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">user_input</span><span class="p">):</span>
    <span class="n">char</span> <span class="o">=</span> <span class="n">user_input</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="c1"># Если встретили стоп-букву 'т', выходим из цикла</span>
    <span class="k">if</span> <span class="n">char</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'t'</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Найдена стоп-буква 'т'. Подсчёт остановлен."</span><span class="p">)</span>
        <span class="k">break</span>  <span class="c1"># Немедленно прерываем цикл</span>

    <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">vowels</span><span class="p">:</span>
        <span class="n">vowels_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Количество гласных до стоп-буквы: </span><span class="si">{</span><span class="n">vowels_count</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre>
</div>
<p>
 <strong>
  Пример работы:
 </strong>
</p>
<ul>
 <li>
  <code>
   hello
  </code>
  -&gt;
  <code>
   2
  </code>
  (e, o)
 </li>
 <li>
  <code>
   amsterdam
  </code>
  -&gt;
  <code>
   1
  </code>
  (a). Цикл встретит
  <code>
   t
  </code>
  и прервётся, не дойдя до второй
  <code>
   a
  </code>
  и
  <code>
   e
  </code>
  .
 </li>
</ul>
<h4 id="2192-пропуск-итерации-оператор-continue">
 2.19.2. Пропуск итерации: оператор
 <code>
  continue
 </code>
</h4>
<p>
 Оператор
 <code>
  continue
 </code>
 прерывает только
 <em>
  текущую итерацию
 </em>
 цикла и немедленно переходит к проверке условия для следующей итерации. Код, следующий за
 <code>
  continue
 </code>
 внутри тела цикла, пропускается.
</p>
<blockquote>
 <p>
  <strong>
   Оператор
   <code>
    continue
   </code>
   (Continue Statement)
  </strong>
  — это ключевое слово, которое завершает текущую итерацию цикла и передаёт управление обратно к проверке условия цикла. В отличие от
  <code>
   break
  </code>
  , он не прерывает цикл полностью.
 </p>
</blockquote>
<p>
 Усложним нашу игру: теперь каждая гласная буква может быть учтена только один раз. Например, в слове «banana» будет засчитана только первая «a».
</p>
<p>
 Для реализации этого мы будем использовать
 <code>
  continue
 </code>
 , чтобы пропустить подсчёт уже встреченной гласной.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">user_input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"Введите текст: "</span><span class="p">)</span>
<span class="n">vowels</span> <span class="o">=</span> <span class="s2">"aeiouyAEIOUY"</span>
<span class="n">counted_vowels</span> <span class="o">=</span> <span class="s2">""</span>  <span class="c1"># Строка для хранения уже посчитанных гласных</span>
<span class="n">vowels_count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">user_input</span><span class="p">):</span>
    <span class="n">char</span> <span class="o">=</span> <span class="n">user_input</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="c1"># Проверяем, является ли символ гласной</span>
    <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">vowels</span><span class="p">:</span>
        <span class="c1"># Если эта гласная уже была посчитана, пропускаем итерацию</span>
        <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">counted_vowels</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Важно: не забываем изменить индекс перед continue!</span>
            <span class="k">continue</span>  <span class="c1"># Переходим к следующей итерации</span>

        <span class="c1"># Если гласная встретилась впервые, считаем её</span>
        <span class="n">vowels_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">counted_vowels</span> <span class="o">+=</span> <span class="n">char</span> <span class="c1"># Добавляем в список учтённых</span>

    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Количество уникальных гласных: </span><span class="si">{</span><span class="n">vowels_count</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre>
</div>
<p>
 <strong>
  Важный нюанс:
 </strong>
 при использовании
 <code>
  continue
 </code>
 в цикле
 <code>
  while
 </code>
 , который управляется вручную через индекс, необходимо убедиться, что переменная-счётчик (
 <code>
  index
 </code>
 ) изменяется до вызова
 <code>
  continue
 </code>
 . В противном случае можно получить бесконечный цикл.
</p>
<h4 id="2193-блок-else-в-цикле">
 2.19.3. Блок
 <code>
  else
 </code>
 в цикле
</h4>
<p>
 Циклы в Python могут иметь блок
 <code>
  else
 </code>
 , который выполняется только в том случае, если цикл завершился «естественно» — то есть его условие стало
 <code>
  False
 </code>
 . Если цикл был прерван оператором
 <code>
  break
 </code>
 , блок
 <code>
  else
 </code>
 не выполняется.
</p>
<blockquote>
 <p>
  <strong>
   Блок
   <code>
    else
   </code>
   в цикле (Loop
   <code>
    else
   </code>
   Block)
  </strong>
  — это опциональный блок кода, который выполняется после завершения цикла, при условии, что он не был прерван оператором
  <code>
   break
  </code>
  . Он используется для выполнения действий, связанных с успешным завершением всех итераций.
 </p>
</blockquote>
<p>
 Добавим в нашу игру начисление бонусных баллов, если пользователь ввёл слово без «стоп-буквы»
 <code>
  т
 </code>
 .
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># ... (начальный код тот же)</span>
<span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">user_input</span><span class="p">):</span>
    <span class="n">char</span> <span class="o">=</span> <span class="n">user_input</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">char</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'t'</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Найдена стоп-буква 'т'. Бонуса не будет."</span><span class="p">)</span>
        <span class="k">break</span>

    <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">vowels</span><span class="p">:</span>
        <span class="n">vowels_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># Этот блок сработает, только если цикл завершился без break</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Слово проверено полностью! Начислен бонус."</span><span class="p">)</span>
    <span class="n">vowels_count</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Добавляем бонусный балл</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Итоговый счёт: </span><span class="si">{</span><span class="n">vowels_count</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre>
</div>
<p>
 Эта возможность позволяет элегантно разделять логику нормального завершения цикла и его досрочного прерывания.
</p>
<h4 id="2194-практика-и-отладка">
 2.19.4. Практика и отладка
</h4>
<p>
 Подобные вложенные условия могут усложнять чтение кода. Хорошей практикой считается избегание вложенности более трёх уровней. Чтобы разобраться в работе такого кода, незаменим
 <strong>
  отладчик
 </strong>
 .
</p>
<blockquote>
 <p>
  <strong>
   Отладчик (Debugger)
  </strong>
  — это инструмент в среде разработки, который позволяет выполнять программу пошагово, отслеживая значения переменных на каждом шаге. Это помогает находить ошибки и понимать логику работы сложного кода.
 </p>
</blockquote>
<p>
 Установив точку останова (breakpoint) и запустив код в режиме отладки (обычно клавиша
 <code>
  F5
 </code>
 ), вы можете наглядно увидеть, как
 <code>
  break
 </code>
 прерывает цикл, а
 <code>
  continue
 </code>
 пропускает часть кода, и когда выполняется блок
 <code>
  else
 </code>
 .
</p>
<h3 id="220-практическая-задача-палиндром-сравнение-подходов">
 2.20. Практическая задача: «Палиндром» — сравнение подходов
</h3>
<p>
 Вернёмся к задаче определения палиндрома и решим её с помощью цикла
 <code>
  while
 </code>
 . Это позволит нам сравнить два разных подхода и обсудить их эффективность.
</p>
<p>
 <strong>
  Напоминание:
 </strong>
</p>
<ul>
 <li>
  <strong>
   Решение 1 (через срез):
  </strong>
  <code>
   word.lower() == word.lower()[::-1]
  </code>
 </li>
</ul>
<p>
 <strong>
  Решение 2 (через цикл
  <code>
   while
  </code>
  ):
 </strong>
 Идея заключается в том, чтобы сравнивать символы с обоих концов строки, двигаясь к центру. Нам понадобятся два «указателя» (индекса): один в начале строки, другой — в конце.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">word</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"Введите слово: "</span><span class="p">)</span>
<span class="n">word</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="c1"># Сразу приводим к нижнему регистру</span>

<span class="c1"># Инициализируем индексы</span>
<span class="n">left_index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">right_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">is_palindrome</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># Предполагаем, что слово - палиндром</span>

<span class="c1"># Цикл работает, пока левый индекс не дошёл до правого</span>
<span class="k">while</span> <span class="n">left_index</span> <span class="o">&lt;</span> <span class="n">right_index</span><span class="p">:</span>
    <span class="c1"># Сравниваем символы с обоих концов</span>
    <span class="k">if</span> <span class="n">word</span><span class="p">[</span><span class="n">left_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">word</span><span class="p">[</span><span class="n">right_index</span><span class="p">]:</span>
        <span class="n">is_palindrome</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Если символы не совпали</span>
        <span class="k">break</span> <span class="c1"># Дальнейшая проверка бессмысленна, выходим из цикла</span>

    <span class="c1"># Сдвигаем индексы к центру</span>
    <span class="n">left_index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">right_index</span> <span class="o">-=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Слово '</span><span class="si">{</span><span class="n">word</span><span class="si">}</span><span class="s2">' является палиндромом: </span><span class="si">{</span><span class="n">is_palindrome</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre>
</div>
<h4 id="2201-какои-подход-лучше-эффективность-алгоритмов">
 2.20.1. Какой подход лучше? Эффективность алгоритмов
</h4>
<p>
 На первый взгляд, решение через срез (
 <code>
  word[::-1]
 </code>
 ) выглядит лучше: оно короче и лаконичнее. Однако с точки зрения производительности, особенно на больших данных, решение с циклом
 <code>
  while
 </code>
 намного эффективнее.
</p>
<blockquote>
 <p>
  <strong>
   Эффективность алгоритма (Algorithmic Efficiency)
  </strong>
  — это характеристика, описывающая, как количество вычислительных ресурсов (время, память) зависит от объёма входных данных. Эффективные алгоритмы выполняют задачу быстрее и с меньшими затратами.
 </p>
</blockquote>
<p>
 <strong>
  Анализ подхода со срезом:
 </strong>
</p>
<ol>
 <li>
  <strong>
   Создание новой строки:
  </strong>
  <code>
   word[::-1]
  </code>
  создаёт в памяти
  <em>
   совершенно новый
  </em>
  строковый объект, который является перевёрнутой копией исходного. Если строка содержит миллион символов, будет выделена память под ещё один миллион.
 </li>
 <li>
  <strong>
   Первый перебор:
  </strong>
  Для создания этой копии Python должен перебрать
  <em>
   все
  </em>
  символы исходной строки.
 </li>
 <li>
  <strong>
   Второй перебор:
  </strong>
  Оператор
  <code>
   ==
  </code>
  сравнивает две строки, снова перебирая все символы от начала до конца, пока не найдёт различие.
 </li>
</ol>
<p>
 <strong>
  Анализ подхода с циклом
  <code>
   while
  </code>
  :
 </strong>
</p>
<ol>
 <li>
  <strong>
   Нет новых объектов:
  </strong>
  Мы работаем с исходной строкой, не создавая её копий. Это экономит память.
 </li>
 <li>
  <strong>
   Один перебор (частичный):
  </strong>
  Мы перебираем строку только до середины. В лучшем случае (если первые же символы не совпадают), цикл выполнит всего одну итерацию. В худшем (если слово — палиндром), мы сделаем примерно
  <code>
   N/2
  </code>
  сравнений, где
  <code>
   N
  </code>
  — длина строки.
 </li>
</ol>
<p>
 <strong>
  Вывод:
 </strong>
 Вариант с циклом
 <code>
  while
 </code>
 значительно экономит память и выполняет меньше операций. Хотя для коротких строк разница незаметна, в профессиональной разработке при работе с большими объёмами данных такой выбор имеет решающее значение. Принцип «краткость — сестра таланта» не всегда применим к эффективности кода.
</p>
<h3 id="221-введение-в-контеинеры-кортежи-tuple">
 2.21. Введение в контейнеры: кортежи (
 <code>
  tuple
 </code>
 )
</h3>
<p>
 До сих пор мы работали с «простыми» типами данных, которые хранят одно значение (число, строку, булево значение). Теперь мы переходим к
 <strong>
  контейнерным типам
 </strong>
 , которые позволяют хранить коллекции других объектов. Первым мы изучим кортеж.
</p>
<blockquote>
 <p>
  <strong>
   Контейнерный тип данных (Container Data Type)
  </strong>
  — это тип данных, предназначенный для хранения коллекции других объектов. Примеры в Python включают кортежи, списки, множества и словари.
 </p>
</blockquote>
<blockquote>
 <p>
  <strong>
   Кортеж (Tuple)
  </strong>
  — это упорядоченная, неизменяемая коллекция элементов. Неизменяемость означает, что после создания кортежа нельзя добавить, удалить или изменить его элементы.
 </p>
</blockquote>
<p>
 Кортежи идеально подходят для хранения наборов данных, которые не должны меняться в ходе выполнения программы, например, настроек, координат, элементов меню.
</p>
<h4 id="2211-создание-кортежеи">
 2.21.1. Создание кортежей
</h4>
<ol>
 <li>
  <p>
   <strong>
    С помощью круглых скобок (литерал кортежа):
   </strong>
  </p>
  <div class="codehilite">
   <pre><span></span><code><span class="c1"># Кортеж с элементами меню сайта</span>
<span class="n">main_menu</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"Home"</span><span class="p">,</span> <span class="s2">"Catalog"</span><span class="p">,</span> <span class="s2">"Payment and Shipping"</span><span class="p">,</span> <span class="s2">"About"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">main_menu</span><span class="p">)</span>
<span class="c1"># Выведет: ('Home', 'Catalog', 'Payment and Shipping', 'About')</span>

<span class="c1"># Кортеж может содержать разнородные типы данных</span>
<span class="n">user_data</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"Alice"</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">user_data</span><span class="p">)</span>
<span class="c1"># Выведет: ('Alice', 28, True)</span>
</code></pre>
  </div>
 </li>
 <li>
  <p>
   <strong>
    С помощью класса-конструктора
    <code>
     tuple()
    </code>
    :
   </strong>
  </p>
  <blockquote>
   <p>
    <strong>
     Класс-конструктор (Constructor Class)
    </strong>
    — это специальный объект (в данном случае
    <code>
     tuple
    </code>
    ), который используется для создания новых экземпляров (объектов) своего типа. Он может принимать другие объекты для инициализации.
   </p>
  </blockquote>
  <p>
   Конструктор
   <code>
    tuple()
   </code>
   может создать кортеж из любой
   <strong>
    итерируемой последовательности
   </strong>
   .
  </p>
  <blockquote>
   <p>
    <strong>
     Итерируемый объект (Iterable)
    </strong>
    — это любой объект, элементы которого можно перебрать по одному, например, строка, кортеж или список.
    <div class="codehilite">
     <pre><span></span><code><span class="c1"># Создание кортежа из строки</span>
  <span class="n">letters</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="s2">"hello"</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
  <span class="c1"># Выведет: ('h', 'e', 'l', 'l', 'o')</span></code></pre>
    </div>
   </p>
  </blockquote>
  <p>
   <span class="c1">
    # Создание пустого кортежа
   </span>
   <span class="n">
    empty
    <em>
     tuple
    </em>
   </span>
   <span class="o">
    =
   </span>
   <span class="nb">
    tuple
   </span>
   <span class="p">
    ()
   </span>
   <span class="nb">
    print
   </span>
   <span class="p">
    (
   </span>
   <span class="n">
    empty
    tuple
   </span>
   <span class="p">
    )
   </span>
   <span class="c1">
    # Выведет: ()
   </span>
  </p>
 </li>
</ol>
<h4 id="2212-особенности-создания-кортежеи">
 2.21.2. Особенности создания кортежей
</h4>
<ul>
 <li>
  <p>
   <strong>
    Кортеж из одного элемента:
   </strong>
   Чтобы создать кортеж из одного элемента, необходимо поставить после него запятую. Без неё скобки будут восприняты как обычные математические скобки.
  </p>
  <div class="codehilite">
   <pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Это не кортеж, это просто число 1</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1"># &lt;class 'int'&gt;</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="c1"># Это кортеж из одного элемента</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="c1"># &lt;class 'tuple'&gt;</span>
</code></pre>
  </div>
 </li>
 <li>
  <p>
   <strong>
    Создание без скобок:
   </strong>
   В большинстве случаев Python позволяет создавать кортежи, просто перечисляя значения через запятую.
  </p>
  <div class="codehilite">
   <pre><span></span><code><span class="n">data</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">"hello"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># (1, 2, 'hello')</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="c1"># &lt;class 'tuple'&gt;</span>
</code></pre>
  </div>
  <p>
   Хотя это возможно,
   <strong>
    лучшей практикой является явное использование круглых скобок
   </strong>
   . Это делает ваше намерение создать кортеж очевидным для всех, кто будет читать код.
  </p>
 </li>
</ul>
<h4 id="2213-работа-с-элементами-кортежа">
 2.21.3. Работа с элементами кортежа
</h4>
<p>
 Поскольку кортежи — упорядоченные последовательности, они поддерживают все те же операции индексации и срезов, что и строки.
</p>
<ul>
 <li>
  <p>
   <strong>
    Доступ по индексу:
   </strong>
  </p>
  <div class="codehilite">
   <pre><span></span><code><span class="n">main_menu</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"Home"</span><span class="p">,</span> <span class="s2">"Catalog"</span><span class="p">,</span> <span class="s2">"Payment and Shipping"</span><span class="p">,</span> <span class="s2">"About"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">main_menu</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>       <span class="c1"># Выведет: 'Home'</span>
<span class="nb">print</span><span class="p">(</span><span class="n">main_menu</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>      <span class="c1"># Выведет: 'About'</span>
</code></pre>
  </div>
 </li>
 <li>
  <p>
   <strong>
    Срезы:
   </strong>
   Срез кортежа возвращает
   <strong>
    новый
   </strong>
   кортеж.
  </p>
  <div class="codehilite">
   <pre><span></span><code><span class="n">sub_menu</span> <span class="o">=</span> <span class="n">main_menu</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># От 1-го до 3-го (не включая)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sub_menu</span><span class="p">)</span>         <span class="c1"># Выведет: ('Catalog', 'Payment and Shipping')</span>
</code></pre>
  </div>
 </li>
 <li>
  <p>
   <strong>
    Конкатенация:
   </strong>
   Можно создавать новые кортежи, объединяя существующие.
  </p>
  <div class="codehilite">
   <pre><span></span><code><span class="n">menu_part1</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"Home"</span><span class="p">,</span> <span class="s2">"Catalog"</span><span class="p">)</span>
<span class="n">menu_part2</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"FAQ"</span><span class="p">,)</span> <span class="c1"># Не забываем запятую!</span>
<span class="n">full_menu</span> <span class="o">=</span> <span class="n">menu_part1</span> <span class="o">+</span> <span class="n">menu_part2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">full_menu</span><span class="p">)</span> <span class="c1"># ('Home', 'Catalog', 'FAQ')</span>
</code></pre>
  </div>
  <p>
   Как и со строками, операция
   <code>
    +=
   </code>
   также создаст новый объект и переприсвоит его переменной.
  </p>
 </li>
</ul>
<h4 id="2214-неизменяемость-на-практике">
 2.21.4. Неизменяемость на практике
</h4>
<p>
 Главное свойство кортежа — его нельзя изменить после создания.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="c1"># data[0] = 5 # Эта строка вызовет ошибку TypeError</span>
</code></pre>
</div>
<p>
 Это свойство делает кортежи надёжным способом хранения данных, которые не должны быть случайно изменены.
</p>
<h3 id="222-распаковка-кортежеи-и-множественное-присваивание">
 2.22. Распаковка кортежей и множественное присваивание
</h3>
<p>
 Одной из самых мощных возможностей, связанных с кортежами, является механизм распаковки.
</p>
<blockquote>
 <p>
  <strong>
   Распаковка (Unpacking)
  </strong>
  — это процесс присваивания элементов коллекции (например, кортежа) отдельным переменным за одну операцию.
 </p>
</blockquote>
<p>
 Этот механизм делает код гораздо более читаемым по сравнению с доступом по числовым индексам.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Вместо этого:</span>
<span class="c1"># current_date = (3, "December", 2023)</span>
<span class="c1"># day = current_date[0]</span>
<span class="c1"># month = current_date[1]</span>
<span class="c1"># year = current_date[2]</span>

<span class="c1"># Можно сделать так:</span>
<span class="n">day</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">year</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s2">"December"</span><span class="p">,</span> <span class="mi">2023</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Сегодня: </span><span class="si">{</span><span class="n">day</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">month</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2"> года"</span><span class="p">)</span>
</code></pre>
</div>
<p>
 Количество переменных слева должно точно совпадать с количеством элементов в кортеже справа, иначе возникнет ошибка
 <code>
  ValueError
 </code>
 .
</p>
<h4 id="2221-множественное-присваивание">
 2.22.1. Множественное присваивание
</h4>
<p>
 На самом деле, множественное присваивание, которое мы видели ранее, работает именно через неявное создание и распаковку кортежа.
</p>
<blockquote>
 <p>
  <strong>
   Множественное присваивание (Multiple Assignment)
  </strong>
  — это синтаксическая конструкция, позволяющая присвоить значения нескольким переменным в одной строке. Интерпретатор сначала формирует кортеж из значений справа, а затем распаковывает его в переменные слева.
 </p>
</blockquote>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Эта запись:</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span>

<span class="c1"># По сути, эквивалентна этой:</span>
<span class="c1"># temp_tuple = (10, 20)</span>
<span class="c1"># x = temp_tuple[0]</span>
<span class="c1"># y = temp_tuple[1]</span>
</code></pre>
</div>
<p>
 При использовании множественного присваивания для лаконичности круглые скобки обычно опускают.
</p>
<h4 id="2222-расширенная-распаковка-с-оператором">
 2.22.2. Расширенная распаковка с оператором
 <code>
  *
 </code>
</h4>
<p>
 Иногда нужно извлечь только часть элементов, а остальные собрать в другую коллекцию. Для этого используется оператор
 <code>
  *
 </code>
 (звёздочка).
</p>
<blockquote>
 <p>
  <strong>
   Оператор
   <code>
    *
   </code>
   (Asterisk Operator)
  </strong>
  в контексте распаковки используется для сбора всех «лишних» элементов из последовательности в список. Переменная с этим оператором может быть только одна.
 </p>
</blockquote>
<div class="codehilite">
 <pre><span></span><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1"># Взять первый элемент, а остальные собрать в список</span>
<span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">numbers</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Первый: </span><span class="si">{</span><span class="n">first</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>   <span class="c1"># Выведет: 1</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Остальные: </span><span class="si">{</span><span class="n">rest</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># Выведет: [2, 3, 4, 5] (обратите внимание, это список!)</span>

<span class="c1"># Взять первый и последний, а то, что между ними, — в список</span>
<span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">middle</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">numbers</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Первый: </span><span class="si">{</span><span class="n">first</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>   <span class="c1"># 1</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Средние: </span><span class="si">{</span><span class="n">middle</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># [2, 3, 4]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Последний: </span><span class="si">{</span><span class="n">last</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># 5</span>
</code></pre>
</div>
<h4 id="2223-игнорирование-ненужных-значении">
 2.22.3. Игнорирование ненужных значений
</h4>
<p>
 Если при распаковке некоторые значения не нужны, для них принято использовать имя переменной в виде одного символа подчёркивания
 <code>
  _
 </code>
 . Это соглашение сообщает другим программистам, что значение намеренно игнорируется.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">record</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"Alice"</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="s2">"Developer"</span><span class="p">,</span> <span class="s2">"New York"</span><span class="p">)</span>

<span class="n">name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">record</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> работает как </span><span class="si">{</span><span class="n">position</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre>
</div>
<h3 id="223-методы-кортежеи-и-прочие-операции">
 2.23. Методы кортежей и прочие операции
</h3>
<p>
 Так как кортежи неизменяемы, у них очень мало методов. По сути, их всего два.
</p>
<ul>
 <li>
  <strong>
   <code>
    count(value)
   </code>
  </strong>
  : Возвращает количество вхождений элемента
  <code>
   value
  </code>
  в кортеж.
 </li>
 <li>
  <strong>
   <code>
    index(value)
   </code>
  </strong>
  : Возвращает индекс первого вхождения элемента
  <code>
   value
  </code>
  . Если элемента нет, вызывает ошибку
  <code>
   ValueError
  </code>
  .
 </li>
</ul>
<div class="codehilite">
 <pre><span></span><code><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'d'</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">'b'</span><span class="p">))</span>  <span class="c1"># Выведет: 2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">'c'</span><span class="p">))</span>  <span class="c1"># Выведет: 2</span>
</code></pre>
</div>
<h4 id="2231-оценка-в-логическом-контексте-и-преобразования">
 2.23.1. Оценка в логическом контексте и преобразования
</h4>
<ul>
 <li>
  <strong>
   <code>
    bool()
   </code>
  </strong>
  : Пустой кортеж
  <code>
   ()
  </code>
  оценивается как
  <code>
   False
  </code>
  . Любой кортеж, содержащий хотя бы один элемент, оценивается как
  <code>
   True
  </code>
  .
 </li>
 <li>
  <strong>
   <code>
    len()
   </code>
  </strong>
  : Возвращает количество элементов в кортеже.
 </li>
 <li>
  <p>
   <strong>
    Объединение в строку с
    <code>
     join()
    </code>
   </strong>
   :
  </p>
  <blockquote>
   <p>
    <strong>
     Метод
     <code>
      str.join(iterable)
     </code>
    </strong>
    — это метод строки, который объединяет элементы итерируемого объекта (например, кортежа строк) в одну строку, используя исходную строку в качестве разделителя.
    <div class="codehilite">
     <pre><span></span><code><span class="c1"># Кортеж должен содержать только строки!</span>
  <span class="n">words</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"Hello"</span><span class="p">,</span> <span class="s2">"Python"</span><span class="p">,</span> <span class="s2">"World"</span><span class="p">)</span></code></pre>
    </div>
   </p>
  </blockquote>
  <p>
   <span class="c1">
    # Объединяем через пробел
   </span>
   <span class="n">
    sentence
   </span>
   <span class="o">
    =
   </span>
   <span class="s2">
    " "
   </span>
   <span class="o">
    .
   </span>
   <span class="n">
    join
   </span>
   <span class="p">
    (
   </span>
   <span class="n">
    words
   </span>
   <span class="p">
    )
   </span>
   <span class="nb">
    print
   </span>
   <span class="p">
    (
   </span>
   <span class="n">
    sentence
   </span>
   <span class="p">
    )
   </span>
   <span class="c1">
    # Выведет: Hello Python World
   </span>
  </p>
  <p>
   <span class="c1">
    # Объединяем через тире
   </span>
   <span class="n">
    csv
    <em>
     like
    </em>
   </span>
   <span class="o">
    =
   </span>
   <span class="s2">
    "-"
   </span>
   <span class="o">
    .
   </span>
   <span class="n">
    join
   </span>
   <span class="p">
    (
   </span>
   <span class="n">
    words
   </span>
   <span class="p">
    )
   </span>
   <span class="nb">
    print
   </span>
   <span class="p">
    (
   </span>
   <span class="n">
    csv
    like
   </span>
   <span class="p">
    )
   </span>
   <span class="c1">
    # Выведет: Hello-Python-World
   </span>
  </p>
 </li>
</ul>
<h4 id="2232-форматирование-длинных-кортежеи-в-коде">
 2.23.2. Форматирование длинных кортежей в коде
</h4>
<p>
 Согласно PEP 8, для лучшей читаемости длинные кортежи можно форматировать, размещая каждый элемент на новой строке.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Вместо неудобной длинной строки:</span>
<span class="c1"># vertebrae = ('C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'T1', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7', 'T8', 'T9', 'T10', 'T11', 'T12', 'L1', 'L2', 'L3', 'L4', 'L5')</span>

<span class="c1"># Можно записать так:</span>
<span class="n">vertebrae</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s1">'C1'</span><span class="p">,</span> <span class="s1">'C2'</span><span class="p">,</span> <span class="s1">'C3'</span><span class="p">,</span> <span class="s1">'C4'</span><span class="p">,</span> <span class="s1">'C5'</span><span class="p">,</span> <span class="s1">'C6'</span><span class="p">,</span> <span class="s1">'C7'</span><span class="p">,</span>
    <span class="s1">'T1'</span><span class="p">,</span> <span class="s1">'T2'</span><span class="p">,</span> <span class="s1">'T3'</span><span class="p">,</span> <span class="s1">'T4'</span><span class="p">,</span> <span class="s1">'T5'</span><span class="p">,</span> <span class="s1">'T6'</span><span class="p">,</span> <span class="s1">'T7'</span><span class="p">,</span> <span class="s1">'T8'</span><span class="p">,</span> <span class="s1">'T9'</span><span class="p">,</span> <span class="s1">'T10'</span><span class="p">,</span> <span class="s1">'T11'</span><span class="p">,</span> <span class="s1">'T12'</span><span class="p">,</span>
    <span class="s1">'L1'</span><span class="p">,</span> <span class="s1">'L2'</span><span class="p">,</span> <span class="s1">'L3'</span><span class="p">,</span> <span class="s1">'L4'</span><span class="p">,</span> <span class="s1">'L5'</span><span class="p">,</span>
<span class="p">)</span>
</code></pre>
</div>
<p>
 Это тот же самый кортеж, но его структура в коде гораздо нагляднее.
</p>
<h3 id="224-введение-в-изменяемые-типы-списки-list">
 2.24. Введение в изменяемые типы: списки (
 <code>
  list
 </code>
 )
</h3>
<p>
 Списки во многом похожи на кортежи, но с одним ключевым отличием: они
 <strong>
  изменяемы
 </strong>
 .
</p>
<blockquote>
 <p>
  <strong>
   Список (List)
  </strong>
  — это упорядоченная, изменяемая коллекция элементов. Изменяемость означает, что после создания списка можно добавлять, удалять и изменять его элементы.
 </p>
</blockquote>
<blockquote>
 <p>
  <strong>
   Изменяемый тип данных (Mutable Data Type)
  </strong>
  — это тип данных, внутреннее состояние (содержимое) которого можно изменить после его создания, не создавая новый объект.
 </p>
</blockquote>
<h4 id="2241-создание-списков">
 2.24.1. Создание списков
</h4>
<ol>
 <li>
  <p>
   <strong>
    С помощью квадратных скобок (литерал списка):
   </strong>
   Это наиболее распространённый способ.
  </p>
  <div class="codehilite">
   <pre><span></span><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">mixed_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s2">"hello"</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">]</span>
</code></pre>
  </div>
 </li>
 <li>
  <p>
   <strong>
    С помощью конструктора
    <code>
     list()
    </code>
    :
   </strong>
  </p>
  <div class="codehilite">
   <pre><span></span><code><span class="c1"># Создание пустого списка</span>
<span class="n">empty_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

<span class="c1"># Создание списка из кортежа</span>
<span class="n">from_tuple</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">from_tuple</span><span class="p">)</span> <span class="c1"># [1, 2, 3]</span>
</code></pre>
  </div>
  <p>
   Для создания пустого списка чаще используют
   <code>
    []
   </code>
   , так как это короче и нагляднее.
  </p>
 </li>
</ol>
<h4 id="2242-сходства-со-списками-и-кортежами">
 2.24.2. Сходства со списками и кортежами
</h4>
<p>
 Списки поддерживают все те же базовые операции, что и кортежи:
</p>
<ul>
 <li>
  <strong>
   Индексация и срезы:
  </strong>
  Работают абсолютно так же. Срез списка возвращает
  <strong>
   новый
  </strong>
  список.
 </li>
 <li>
  <strong>
   <code>
    len()
   </code>
  </strong>
  : Возвращает длину списка.
 </li>
 <li>
  <strong>
   <code>
    bool()
   </code>
  </strong>
  : Пустой список
  <code>
   []
  </code>
  — это
  <code>
   False
  </code>
  , любой непустой —
  <code>
   True
  </code>
  .
 </li>
</ul>
<h4 id="2243-главное-отличие-изменяемость">
 2.24.3. Главное отличие: изменяемость
</h4>
<p>
 В отличие от кортежей, элементы списка можно изменять по индексу. Эта операция происходит «на месте», то есть сам объект списка не меняется, меняется лишь его содержимое.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"ID до изменения: </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="c1"># Заменяем элемент по индексу 1</span>
<span class="n">data_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"four"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span> <span class="c1"># Выведет: [2, 'four', 6, 8, 10]</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"ID после изменения: </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># ID останется тем же!</span>
</code></pre>
</div>
<h4 id="2244-особенности-операции">
 2.24.4. Особенности операции
 <code>
  +=
 </code>
</h4>
<p>
 Для изменяемых типов, таких как списки, сокращённая операция
 <code>
  +=
 </code>
 ведёт себя иначе, чем полная
 <code>
  +
 </code>
 .
</p>
<ul>
 <li>
  <code>
   list1 = list1 + list2
  </code>
  : Эта операция создаёт
  <strong>
   новый
  </strong>
  список, объединяя
  <code>
   list1
  </code>
  и
  <code>
   list2
  </code>
  , и присваивает ссылку на него переменной
  <code>
   list1
  </code>
  .
 </li>
 <li>
  <code>
   list1 += list2
  </code>
  : Эта операция
  <strong>
   изменяет существующий
  </strong>
  список
  <code>
   list1
  </code>
  , добавляя в него элементы из
  <code>
   list2
  </code>
  . Новый объект не создаётся.
 </li>
</ul>
<div class="codehilite">
 <pre><span></span><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Начальный ID: </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="c1"># Используем +=</span>
<span class="n">numbers</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> 
<span class="nb">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1"># [1, 2, 3, 4, 5]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"ID после +=: </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># ID не изменился</span>

<span class="c1"># Используем +</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="n">numbers</span> <span class="o">+</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1"># [1, 2, 3, 4, 5, 6, 7]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"ID после +: </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># ID изменился, создан новый объект</span>
</code></pre>
</div>
<p>
 Это ключевое отличие в поведении, которое важно понимать при работе с изменяемыми типами данных для управления памятью и избежания неожиданных побочных эффектов.
</p>
<p>
 Конечно, вот преобразованный и структурированный текст, соответствующий вашим требованиям.
</p>
<hr/>
<h3 id="225-особенности-изменяемых-типов-идентичность-и-копирование">
 2.25. Особенности изменяемых типов: идентичность и копирование
</h3>
<p>
 Списки, как изменяемый тип данных, обладают рядом ключевых особенностей, которые отличают их от неизменяемых типов, таких как кортежи и строки. Понимание этих различий критически важно для написания предсказуемого и эффективного кода.
</p>
<h4 id="2251-отсутствие-кэширования">
 2.25.1. Отсутствие кэширования
</h4>
<p>
 В отличие от коротких строк или небольших целых чисел, которые Python может кэшировать для оптимизации памяти, списки никогда не кэшируются. Поскольку основное предназначение списка — возможность изменения, интерпретатор всегда создаёт новый, уникальный объект списка в памяти, даже если его содержимое полностью идентично другому списку.
</p>
<blockquote>
 <p>
  <strong>
   Кэширование (Caching)
  </strong>
  — это процесс сохранения результатов операций или часто используемых данных во временном хранилище для ускорения последующего доступа к ним. Изменяемые объекты, такие как списки, обычно не кэшируются, поскольку их содержимое может измениться в любой момент.
 </p>
</blockquote>
<div class="codehilite">
 <pre><span></span><code><span class="n">data_list_1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">data_list_2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="c1"># ID будут разными, так как созданы два независимых объекта</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">data_list_1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">data_list_2</span><span class="p">))</span> 
</code></pre>
</div>
<h4 id="2252-ссылки-и-побочные-эффекты">
 2.25.2. Ссылки и побочные эффекты
</h4>
<p>
 Когда вы присваиваете одну переменную со списком другой, вы не создаёте копию списка. Вместо этого вы копируете
 <strong>
  ссылку
 </strong>
 на один и тот же объект в памяти. Обе переменные начинают указывать на один и тот же список.
</p>
<blockquote>
 <p>
  <strong>
   Ссылка на объект (Object Reference)
  </strong>
  — это, по сути, адрес в памяти, где хранится объект. Переменная в Python не содержит сам объект, а лишь хранит ссылку на него.
 </p>
</blockquote>
<p>
 Это приводит к важному побочному эффекту: изменение объекта через одну переменную будет видно при обращении к этому объекту через другую переменную.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">list1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="n">list2</span> <span class="o">=</span> <span class="n">list1</span> <span class="c1"># list2 теперь ссылается на тот же объект, что и list1</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"ID list1: </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"ID list2: </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># ID будут одинаковыми</span>

<span class="c1"># Изменяем объект через list2</span>
<span class="n">list2</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">40</span><span class="p">]</span>

<span class="c1"># Изменения видны и в list1, потому что объект один</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"list1 после изменения: </span><span class="si">{</span><span class="n">list1</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># Выведет: [10, 20, 30, 40]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"list2 после изменения: </span><span class="si">{</span><span class="n">list2</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># Выведет: [10, 20, 30, 40]</span>
</code></pre>
</div>
<p>
 С этим поведением нужно быть особенно осторожным, чтобы избежать непреднамеренного изменения данных.
</p>
<h4 id="2253-разница-между-и-для-списков">
 2.25.3. Разница между
 <code>
  +
 </code>
 и
 <code>
  +=
 </code>
 для списков
</h4>
<p>
 Как мы уже видели, для изменяемых типов сокращённая (
 <code>
  +=
 </code>
 ) и полная (
 <code>
  +
 </code>
 ) формы оператора сложения работают по-разному:
</p>
<ul>
 <li>
  <strong>
   <code>
    list1 = list1 + list2
   </code>
  </strong>
  : Эта операция создаёт
  <strong>
   новый
  </strong>
  список в памяти, являющийся результатом объединения двух исходных. Затем ссылка на этот новый объект присваивается переменной
  <code>
   list1
  </code>
  .
 </li>
 <li>
  <strong>
   <code>
    list1 += list2
   </code>
  </strong>
  : Эта операция
  <strong>
   изменяет существующий
  </strong>
  объект
  <code>
   list1
  </code>
  «на месте», добавляя в него элементы из
  <code>
   list2
  </code>
  . Новый объект не создаётся.
 </li>
</ul>
<div class="codehilite">
 <pre><span></span><code><span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Начальный ID: </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="c1"># Присваиваем ссылку на тот же объект</span>
<span class="n">data_list_2</span> <span class="o">=</span> <span class="n">data_list</span>

<span class="c1"># Используем полную форму, которая создаёт НОВЫЙ объект</span>
<span class="n">data_list</span> <span class="o">=</span> <span class="n">data_list</span> <span class="o">+</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"ID data_list после '+': </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># ID изменился</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"ID data_list_2: </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">data_list_2</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>       <span class="c1"># ID остался прежним</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"data_list: </span><span class="si">{</span><span class="n">data_list</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>     <span class="c1"># [1, 2, 3, 4, 5]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"data_list_2: </span><span class="si">{</span><span class="n">data_list_2</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="c1"># [1, 2, 3] - остался без изменений</span>
</code></pre>
</div>
<h3 id="226-практическая-задача-расчет-скидок">
 2.26. Практическая задача: расчёт скидок
</h3>
<p>
 Рассмотрим практический пример. У нас есть список цен на товары, и нам нужно создать новый список, в котором все цены будут снижены на 10%.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="n">prices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">525</span><span class="p">,</span> <span class="mi">1599</span><span class="p">,</span> <span class="mi">125</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">450</span><span class="p">]</span>
</code></pre>
</div>
<h4 id="2261-решение-1-создание-нового-списка">
 2.26.1. Решение 1: Создание нового списка
</h4>
<p>
 Самый безопасный и распространённый подход — создать новый пустой список и наполнить его рассчитанными значениями, перебирая исходный список в цикле
 <code>
  while
 </code>
 .
</p>
<blockquote>
 <p>
  <strong>
   Числа с плавающей точкой (Floating-Point Numbers)
  </strong>
  — это тип данных для представления вещественных чисел (чисел с дробной частью). Из-за особенностей их двоичного представления в компьютере они могут приводить к небольшим неточностям в вычислениях.
 </p>
</blockquote>
<blockquote>
 <p>
  <strong>
   Встроенная функция (Built-in Function)
  </strong>
  — это функция, которая является частью стандартной библиотеки Python и доступна для использования без необходимости импорта каких-либо модулей. Примеры:
  <code>
   len()
  </code>
  ,
  <code>
   print()
  </code>
  ,
  <code>
   round()
  </code>
  .
 </p>
</blockquote>
<div class="codehilite">
 <pre><span></span><code><span class="n">discount_prices</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Изначально пустой новый список</span>
<span class="n">discount_rate</span> <span class="o">=</span> <span class="mf">0.9</span>   <span class="c1"># Множитель для скидки в 10% (остаётся 90% от цены)</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">):</span>
    <span class="c1"># Получаем цену из исходного списка</span>
    <span class="n">current_price</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># Вычисляем новую цену</span>
    <span class="n">new_price</span> <span class="o">=</span> <span class="n">current_price</span> <span class="o">*</span> <span class="n">discount_rate</span>

    <span class="c1"># Округляем результат, чтобы избежать некрасивых "хвостов"</span>
    <span class="n">rounded_price</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">new_price</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Добавляем вычисленное значение в НОВЫЙ список</span>
    <span class="n">discount_prices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">rounded_price</span><span class="p">]</span> <span class="c1"># Используем += для расширения списка</span>

    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Список со скидками: </span><span class="si">{</span><span class="n">discount_prices</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="c1"># Выведет: Список со скидками: [472.5, 1439.1, 112.5, 80.1, 405.0]</span>
</code></pre>
</div>
<p>
 При таком подходе исходный список
 <code>
  prices
 </code>
 остаётся нетронутым.
</p>
<h4 id="2262-решение-2-изменение-исходного-списка">
 2.26.2. Решение 2: Изменение исходного списка
</h4>
<p>
 В некоторых случаях может потребоваться изменить значения непосредственно в исходном списке. Это экономит память, но приводит к потере исходных данных.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># prices = [525, 1599, 125, 89, 450] # Исходный список</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">discount_rate</span> <span class="o">=</span> <span class="mf">0.9</span>

<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">):</span>
    <span class="c1"># Получаем доступ к ЯЧЕЙКЕ списка по индексу и присваиваем новое значение</span>
    <span class="n">new_price</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">discount_rate</span>
    <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">new_price</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Изменённый исходный список: </span><span class="si">{</span><span class="n">prices</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="c1"># Выведет: Изменённый исходный список: [472.5, 1439.1, 112.5, 80.1, 405.0]</span>
</code></pre>
</div>
<p>
 <strong>
  Важно:
 </strong>
 Этот подход следует использовать с осторожностью. Если исходные данные были получены из внешнего источника (например, с сайта или из базы данных), их изменение может привести к необратимой потере информации.
</p>
<h3 id="227-ключевые-своиства-списков-резюме">
 2.27. Ключевые свойства списков: резюме
</h3>
<ul>
 <li>
  <strong>
   Изменяемость:
  </strong>
  Списки — изменяемый тип данных. Их содержимое можно менять после создания.
 </li>
 <li>
  <strong>
   Доступ и изменение по индексу:
  </strong>
  <ul>
   <li>
    <code>
     value = my_list[i]
    </code>
    — это выражение для
    <strong>
     получения значения
    </strong>
    из ячейки.
   </li>
   <li>
    <code>
     my_list[i] = new_value
    </code>
    — это инструкция для
    <strong>
     записи нового значения
    </strong>
    в ячейку. Исходное значение в этой ячейке будет утеряно.
   </li>
  </ul>
 </li>
 <li>
  <strong>
   Оператор
   <code>
    +=
   </code>
   :
  </strong>
  Расширяет существующий список, не создавая нового объекта.
 </li>
 <li>
  <strong>
   Копирование:
  </strong>
  <ul>
   <li>
    <code>
     new_list = old_list
    </code>
    — создаёт
    <strong>
     ссылку
    </strong>
    , а не копию.
   </li>
   <li>
    <code>
     new_list = old_list[:]
    </code>
    — создаёт
    <strong>
     поверхностную копию
    </strong>
    (новый объект списка). Изменения в
    <code>
     old_list
    </code>
    не затронут
    <code>
     new_list
    </code>
    .
   </li>
  </ul>
 </li>
 <li>
  <strong>
   Составные операции присваивания:
  </strong>
  Можно изменять значение ячейки на основе его же текущего значения.
  <div class="codehilite">
   <pre><span></span><code><span class="n">prices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">]</span>
<span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">50</span> <span class="c1"># Эквивалентно prices[0] = prices[0] + 50</span>
<span class="nb">print</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>   <span class="c1"># Выведет: [150, 200]</span>
</code></pre>
  </div>
 </li>
</ul>
<h3 id="228-методы-списков">
 2.28. Методы списков
</h3>
<p>
 Списки имеют богатый набор методов для манипулирования их содержимым.
</p>
<blockquote>
 <p>
  <strong>
   Метод (Method)
  </strong>
  — это функция, которая «принадлежит» объекту определённого типа. Методы вызываются через точку после имени объекта (
  <code>
   object.method()
  </code>
  ) и могут получать доступ к внутреннему состоянию этого объекта и изменять его.
 </p>
</blockquote>
<h4 id="2281-методы-общие-с-кортежами-count-index">
 2.28.1. Методы, общие с кортежами (
 <code>
  count
 </code>
 ,
 <code>
  index
 </code>
 )
</h4>
<ul>
 <li>
  <strong>
   <code>
    count(value)
   </code>
  </strong>
  : Возвращает количество вхождений элемента
  <code>
   value
  </code>
  в список.
 </li>
 <li>
  <strong>
   <code>
    index(value)
   </code>
  </strong>
  : Возвращает индекс первого вхождения элемента
  <code>
   value
  </code>
  . Вызывает ошибку
  <code>
   ValueError
  </code>
  , если элемент не найден.
 </li>
</ul>
<h4 id="2282-методы-добавления-элементов-append-extend">
 2.28.2. Методы добавления элементов (
 <code>
  append
 </code>
 ,
 <code>
  extend
 </code>
 )
</h4>
<ul>
 <li>
  <strong>
   <code>
    append(element)
   </code>
  </strong>
  : Добавляет
  <strong>
   один
  </strong>
  элемент в конец списка. Если передать в
  <code>
   append
  </code>
  другой список, он будет добавлен как один вложенный элемент.
 </li>
 <li>
  <strong>
   <code>
    extend(iterable)
   </code>
  </strong>
  : Расширяет список, добавляя в него все элементы из переданного итерируемого объекта (например, другого списка или кортежа). Этот метод работает аналогично операции
  <code>
   +=
  </code>
  .
 </li>
</ul>
<div class="codehilite">
 <pre><span></span><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">numbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>          <span class="c1"># [1, 2, 3]</span>
<span class="n">numbers</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>     <span class="c1"># [1, 2, 3, 4, 5]</span>
<span class="n">numbers</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>     <span class="c1"># [1, 2, 3, 4, 5, [6, 7]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
</code></pre>
</div>
<h4 id="2283-методы-удаления-элементов-clear-remove-pop">
 2.28.3. Методы удаления элементов (
 <code>
  clear
 </code>
 ,
 <code>
  remove
 </code>
 ,
 <code>
  pop
 </code>
 )
</h4>
<ul>
 <li>
  <strong>
   <code>
    clear()
   </code>
  </strong>
  : Удаляет все элементы из списка, делая его пустым.
 </li>
 <li>
  <strong>
   <code>
    remove(value)
   </code>
  </strong>
  : Удаляет
  <strong>
   первое
  </strong>
  вхождение элемента с указанным значением
  <code>
   value
  </code>
  . Вызывает
  <code>
   ValueError
  </code>
  , если элемент не найден.
 </li>
 <li>
  <strong>
   <code>
    pop([index])
   </code>
  </strong>
  : Удаляет элемент по указанному индексу и
  <strong>
   возвращает его
  </strong>
  . Если индекс не указан, удаляет и возвращает последний элемент. Это единственный из изменяющих методов, который возвращает полезное значение.
 </li>
</ul>
<div class="codehilite">
 <pre><span></span><code><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">]</span>
<span class="n">data</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># Удалит первое вхождение 20. Список станет: [10, 30, 20, 40]</span>
<span class="n">last_item</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># Удалит и вернёт 40. Список: [10, 30, 20]</span>
<span class="n">first_item</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Удалит и вернёт 10. Список: [30, 20]</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Удалённые элементы: </span><span class="si">{</span><span class="n">last_item</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">first_item</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Итоговый список: </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre>
</div>
<p>
 Метод
 <code>
  pop()
 </code>
 часто используется для реализации простых структур данных, таких как
 <strong>
  очередь
 </strong>
 (когда элементы добавляются в конец, а извлекаются из начала) или
 <strong>
  стек
 </strong>
 (когда элементы добавляются и извлекаются с одного и того же конца).
</p>
<blockquote>
 <p>
  <strong>
   Стек (Stack)
  </strong>
  — это структура данных, работающая по принципу «последним пришёл — первым ушёл» (LIFO, Last-In, First-Out). Новые элементы добавляются на вершину стека, и с неё же происходит их изъятие.
 </p>
</blockquote>
<blockquote>
 <p>
  <strong>
   Очередь (Queue)
  </strong>
  — это структура данных, работающая по принципу «первым пришёл — первым ушёл» (FIFO, First-In, First-Out). Элементы добавляются в конец очереди, а извлекаются из её начала.
 </p>
</blockquote>
<h4 id="2284-методы-сортировки-и-изменения-порядка-sort-reverse">
 2.28.4. Методы сортировки и изменения порядка (
 <code>
  sort
 </code>
 ,
 <code>
  reverse
 </code>
 )
</h4>
<ul>
 <li>
  <strong>
   <code>
    sort(key=None, reverse=False)
   </code>
  </strong>
  : Сортирует элементы списка
  <strong>
   на месте
  </strong>
  . По умолчанию сортирует по возрастанию. Параметр
  <code>
   reverse=True
  </code>
  сортирует по убыванию.
 </li>
 <li>
  <strong>
   <code>
    reverse()
   </code>
  </strong>
  : Переворачивает порядок элементов в списке
  <strong>
   на месте
  </strong>
  .
 </li>
</ul>
<h4 id="2285-создание-копии-copy">
 2.28.5. Создание копии (
 <code>
  copy
 </code>
 )
</h4>
<ul>
 <li>
  <strong>
   <code>
    copy()
   </code>
  </strong>
  : Возвращает поверхностную копию списка. Это действие полностью аналогично созданию среза
  <code>
   my_list[:]
  </code>
  .
 </li>
</ul>
<h3 id="229-каскадное-применение-методов-и-возвращаемые-значения">
 2.29. Каскадное применение методов и возвращаемые значения
</h3>
<h4 id="2291-возвращаемое-значение-none-у-изменяющих-методов">
 2.29.1. Возвращаемое значение
 <code>
  None
 </code>
 у изменяющих методов
</h4>
<p>
 Ключевой момент, который нужно запомнить: большинство методов, изменяющих список на месте (
 <code>
  append
 </code>
 ,
 <code>
  extend
 </code>
 ,
 <code>
  sort
 </code>
 ,
 <code>
  remove
 </code>
 и др.),
 <strong>
  ничего не возвращают
 </strong>
 . Точнее, они возвращают специальное значение
 <code>
  None
 </code>
 .
</p>
<blockquote>
 <p>
  <strong>
   None
  </strong>
  — это специальный объект в Python, представляющий отсутствие значения или «пустоту». Функции и методы, которые выполняют действие, но не должны возвращать результат (например,
  <code>
   print()
  </code>
  или
  <code>
   list.sort()
  </code>
  ), возвращают
  <code>
   None
  </code>
  .
 </p>
</blockquote>
<p>
 Из-за этого нельзя писать так:
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># НЕПРАВИЛЬНО!</span>
<span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">sorted_list</span> <span class="o">=</span> <span class="n">my_list</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span> <span class="c1"># sort() вернёт None</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sorted_list</span><span class="p">)</span> <span class="c1"># Выведет: None</span>
</code></pre>
</div>
<p>
 Правильно делать так:
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># ПРАВИЛЬНО</span>
<span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">my_list</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span> <span class="c1"># Изменяем список на месте</span>
<span class="nb">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">)</span> <span class="c1"># Выведет: [1, 2, 3]</span>
</code></pre>
</div>
<h4 id="2292-сравнение-каскадного-вызова-для-изменяемых-и-неизменяемых-типов">
 2.29.2. Сравнение каскадного вызова для изменяемых и неизменяемых типов
</h4>
<p>
 Это различие в возвращаемых значениях напрямую влияет на возможность каскадного применения методов.
</p>
<blockquote>
 <p>
  <strong>
   Каскадное применение методов (Method Chaining)
  </strong>
  — это практика последовательного вызова нескольких методов на одном объекте или на результатах предыдущих вызовов в одной строке кода.
 </p>
</blockquote>
<ul>
 <li>
  <p>
   <strong>
    Для неизменяемых типов (например, строк)
   </strong>
   : каждый метод возвращает
   <strong>
    новый
   </strong>
   объект, к которому можно тут же применить следующий метод.
  </p>
  <div class="codehilite">
   <pre><span></span><code><span class="n">text</span> <span class="o">=</span> <span class="s2">"  Hello, World!  "</span>
<span class="c1"># lower() возвращает новую строку, к которой применяется replace(), и т.д.</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"!"</span><span class="p">,</span> <span class="s2">"."</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1"># "hello, world."</span>
</code></pre>
  </div>
 </li>
 <li>
  <p>
   <strong>
    Для изменяемых типов (списков)
   </strong>
   : так как изменяющие методы возвращают
   <code>
    None
   </code>
   , к этому результату нельзя применить следующий метод.
  </p>
  <div class="codehilite">
   <pre><span></span><code><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="c1"># НЕПРАВИЛЬНО! Вызовет ошибку AttributeError: 'NoneType' object has no attribute 'reverse'</span>
<span class="c1"># my_list.sort().reverse() </span>
</code></pre>
  </div>
 </li>
</ul>
<h3 id="230-практическая-задача-нормализация-спарсенных-данных">
 2.30. Практическая задача: нормализация спарсенных данных
</h3>
<h4 id="2301-постановка-задачи">
 2.30.1. Постановка задачи
</h4>
<p>
 Представим, что программист написал скрипт для сбора цен с сайта.
</p>
<blockquote>
 <p>
  <strong>
   Парсинг / Спарсить (Parsing / To Parse)
  </strong>
  — это процесс автоматизированного сбора и извлечения данных с веб-страниц или из других источников. Программы, выполняющие парсинг, называются парсерами или скраперами.
 </p>
</blockquote>
<p>
 В результате он получил список, но с проблемами:
</p>
<ol>
 <li>
  Все цены — это строки, а не числа.
 </li>
 <li>
  В качестве десятичного разделителя используется запятая, а не точка.
 </li>
 <li>
  В списке присутствуют «артефакты» — пустые строки на месте товаров без цены.
 </li>
</ol>
<blockquote>
 <p>
  <strong>
   Артефакт (Artifact)
  </strong>
  в контексте данных — это нежелательный или непредусмотренный элемент, появившийся в результате сбоя, ошибки в логике или особенностей источника данных.
 </p>
</blockquote>
<p>
 <strong>
  Исходные данные:
 </strong>
 <code>
  scraped_prices = ['1250,5', '899,0', '', '2599,99', '', '1750,0', '199,9']
 </code>
</p>
<p>
 <strong>
  Цель:
 </strong>
 Создать новый, «нормализованный» список, содержащий только корректные цены в виде чисел типа
 <code>
  float
 </code>
 .
</p>
<h4 id="2302-пошаговое-решение-с-циклом-while">
 2.30.2. Пошаговое решение с циклом
 <code>
  while
 </code>
</h4>
<div class="codehilite">
 <pre><span></span><code><span class="n">scraped_prices</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'1250,5'</span><span class="p">,</span> <span class="s1">'899,0'</span><span class="p">,</span> <span class="s1">''</span><span class="p">,</span> <span class="s1">'2599,99'</span><span class="p">,</span> <span class="s1">''</span><span class="p">,</span> <span class="s1">'1750,0'</span><span class="p">,</span> <span class="s1">'199,9'</span><span class="p">]</span>
<span class="n">normalized_prices</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">scraped_prices</span><span class="p">):</span>
    <span class="c1"># Получаем очередной элемент из исходного списка</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">scraped_prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># 1. Проверяем, не является ли строка пустой</span>
    <span class="c1"># Пустая строка ('') в логическом контексте даёт False</span>
    <span class="k">if</span> <span class="n">item</span><span class="p">:</span>
        <span class="c1"># 2. Заменяем запятую на точку</span>
        <span class="n">corrected_item</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">','</span><span class="p">,</span> <span class="s1">'.'</span><span class="p">)</span>

        <span class="c1"># 3. Конвертируем строку в float</span>
        <span class="n">price_float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">corrected_item</span><span class="p">)</span>

        <span class="c1"># 4. Добавляем результат в новый список</span>
        <span class="n">normalized_prices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">price_float</span><span class="p">)</span>

    <span class="c1"># Не забываем увеличивать индекс в любом случае</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Нормализованный список цен: </span><span class="si">{</span><span class="n">normalized_prices</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="c1"># Выведет: [1250.5, 899.0, 2599.99, 1750.0, 199.9]</span>
</code></pre>
</div>
<h3 id="231-как-не-надо-делать-опасности-изменения-списка-при-итерации">
 2.31. «Как не надо делать»: опасности изменения списка при итерации
</h3>
<p>
 Крайне не рекомендуется изменять размер списка (удалять или добавлять элементы) во время его перебора. Это может привести к непредсказуемым результатам, таким как пропуск элементов или ошибки.
</p>
<blockquote>
 <p>
  <strong>
   Итерация / Итерировать (Iteration / To Iterate)
  </strong>
  — это процесс последовательного перебора элементов коллекции (например, списка или строки), обычно для выполнения каких-либо действий с каждым элементом.
 </p>
</blockquote>
<p>
 Рассмотрим, что произошло бы, если бы мы попытались решить предыдущую задачу, изменяя исходный список
 <code>
  scraped_prices
 </code>
 на месте.
</p>
<h4 id="2311-пример-1-удаление-с-помощью-remove">
 2.31.1. Пример 1: Удаление с помощью
 <code>
  remove()
 </code>
</h4>
<p>
 Метод
 <code>
  remove()
 </code>
 удаляет
 <em>
  первое
 </em>
 найденное вхождение элемента, а не тот, на который указывает текущий индекс. Это приводит к хаосу. Когда цикл доходит до первой пустой строки,
 <code>
  remove('')
 </code>
 удаляет самую первую пустую строку в списке. При следующей итерации, из-за сдвига, некоторые элементы будут пропущены.
</p>
<h4 id="2312-пример-2-удаление-с-помощью-popi">
 2.31.2. Пример 2: Удаление с помощью
 <code>
  pop(i)
 </code>
</h4>
<p>
 При удалении элемента по текущему индексу
 <code>
  i
 </code>
 с помощью
 <code>
  pop(i)
 </code>
 , список укорачивается. Однако счётчик
 <code>
  i
 </code>
 продолжает увеличиваться. В результате, следующий за удалённым элемент оказывается «перепрыгнут» и не обрабатывается.
</p>
<div class="codehilite">
 <pre><span></span><code><span class="c1"># Упрощённый пример проблемы</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">numbers</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1"># Список сокращается, элементы сдвигаются влево</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Индекс увеличивается независимо от удаления</span>

<span class="nb">print</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1"># Неожиданный результат: [1, 2, 0, 3]. Второй 0 был пропущен.</span>
</code></pre>
</div>
<h4 id="2313-ключевые-выводы-и-риски">
 2.31.3. Ключевые выводы и риски
</h4>
<ul>
 <li>
  <strong>
   Пропуск элементов:
  </strong>
  Изменение длины списка во время итерации почти всегда приводит к пропуску элементов.
 </li>
 <li>
  <strong>
   Ошибка
   <code>
    IndexError
   </code>
   :
  </strong>
  Если длина списка была вычислена один раз в начале, а затем список сокращался, цикл попытается обратиться к несуществующим индексам.
 </li>
 <li>
  <strong>
   Проблемы с многопоточностью:
  </strong>
  В более сложных программах, где несколько потоков могут работать с одним списком, изменение его «на лету» одним потоком может сломать логику работы других.
 </li>
</ul>
<blockquote>
 <p>
  <strong>
   Многопоточность (Multi-threading)
  </strong>
  — это способность программы выполнять несколько задач (потоков) параллельно. Это усложняет управление общими данными, так как разные потоки могут пытаться читать и изменять их одновременно.
 </p>
</blockquote>
<p>
 <strong>
  Вывод:
 </strong>
 Избегайте изменения размера списка, по которому вы итерируетесь. Предпочтительный и безопасный подход — создавать новый список с нужными элементами. Хоть это и не является абсолютным табу, и в редких случаях опытные разработчики могут управлять индексами вручную, для большинства задач это считается плохой практикой — не «по-питонски».
</p>
<blockquote>
 <p>
  <strong>
   Pythonic Way (Путь Python)
  </strong>
  — это набор идиом и соглашений в программировании на Python, которые подчёркивают читаемость, простоту и ясность кода. Действия, нарушающие эти принципы, часто называют «не-питоническими».
 </p>
</blockquote>

</body>
</html>
